///////////////////////////////////////////////////////////////////////////////////////////////
// This file was generated by <HairWorks>/external/shader_preprocess/bin/shader_preprocess.exe 
// Source file:			NvHairInterpolateDomainOpt.hlsl
// Include path:		..\..\..\Nv\HairWorks\Internal\Shader\Domain\
// Output file:			..\..\..\Nv\HairWorks\Internal\Shader\Generated\NvHairInterpolateDomainOpt.cpp
// Generated at 2017-04-16.23:28:09
///////////////////////////////////////////////////////////////////////////////////////////////
const char* shaderVar =
"#define OPTIMIZE_RUNTIME\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifdef OPTIMIZE_RUNTIME\n"
"\n"
"#define USE_PIXEL_DENSITY 		_USE_PIXEL_DENSITY_\n"
"#define USE_CULL_SPHERE 		_USE_CULL_SPHERE_\n"
"\n"
"#define USE_CLUMPING			_USE_CLUMPING_\n"
"#define USE_WAVINESS			_USE_WAVINESS_\n"
"#define USE_WAVE_CLUMP			_USE_WAVE_CLUMP_\n"
"\n"
"\n"
"#define	USE_DENSITY_TEXTURE			_USE_DENSITY_TEXTURE_\n"
"\n"
"#define	USE_WAVE_SCALE_TEXTURE		_USE_WAVE_SCALE_TEXTURE_\n"
"#define	USE_WAVE_FREQ_TEXTURE		_USE_WAVE_FREQ_TEXTURE_\n"
"\n"
"#define	USE_CLUMP_SCALE_TEXTURE			_USE_CLUMP_SCALE_TEXTURE_\n"
"#define	USE_CLUMP_ROUNDNESS_TEXTURE		_USE_CLUMP_ROUNDNESS_TEXTURE_\n"
"\n"
"#define	USE_WIDTH_TEXTURE			_USE_WIDTH_TEXTURE_\n"
"\n"
"#define	USE_LENGTH_TEXTURE			_USE_LENGTH_TEXTURE_\n"
"\n"
"#define SAMPLE_DENSITY				_SAMPLE_DENSITY_\n"
"#define SAMPLE_LENGTH				_SAMPLE_LENGTH_\n"
"#define SAMPLE_WIDTH				_SAMPLE_WIDTH_\n"
"\n"
"#define SAMPLE_WAVE_SCALE			_SAMPLE_WAVE_SCALE_\n"
"#define SAMPLE_WAVE_FREQ			_SAMPLE_WAVE_FREQ_\n"
"#define SAMPLE_CLUMP_SCALE			_SAMPLE_CLUMP_SCALE_\n"
"#define SAMPLE_CLUMP_ROUNDNESS		_SAMPLE_CLUMP_ROUNDNESS_\n"
"\n"
"#endif\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"#define NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"\n"
"#define NUM_INTERPOLATED_ATTRIBUTES_MINUS_ONE 1023\n"
"#define NUM_INTERPOLATED_ATTRIBUTES 1024\n"
"#define LUT_SIZE_MINUS_ONE 1023\n"
"\n"
"#define NHAIRS_PER_PATCH 64\n"
"#define NSEGMENTS_PER_PATCH 256 \n"
"\n"
"#define TWO_PI 3.141592 * 2.0f\n"
"\n"
"#ifndef FLT_EPSILON\n"
"#define FLT_EPSILON	0.0000001f\n"
"#endif\n"
"\n"
"#ifdef _CPP // C++ code\n"
"\n"
"#define float4			gfsdk_float4\n"
"#define float3			gfsdk_float3\n"
"#define float2			gfsdk_float2\n"
"#define float4x4		gfsdk_float4x4\n"
"#define matrix4			gfsdk_float4x4\n"
"#define DualQuaternion	gfsdk_dualquaternion\n"
"\n"
"typedef int				int2[2];\n"
"typedef int				int4[4];\n"
"\n"
"#define lerp			gfsdk_lerp\n"
"\n"
"#else // shader\n"
"\n"
"struct DualQuaternion\n"
"{\n"
"	float4 q0;\n"
"	float4 q1;\n"
"};\n"
"\n"
"#define matrix4			row_major float4x4\n"
"#define MATERIAL_CHANNELS	float2\n"
"\n"
"inline float NvHair_LerpChannel(float2 channel, float s)\n"
"{\n"
"	return channel.x;\n"
"}\n"
"\n"
"#define SAMPLE_RED(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).r;\n"
"#define SAMPLE_GREEN(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).g;\n"
"#define SAMPLE_BLUE(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).b;\n"
"#define SAMPLE_ALPHA(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).a;\n"
"\n"
"#define NV_HAIR_SAMPLE_CHANNEL(TEX, SAMPLER, TEXCOORD, MIPLEVEL, CHANNEL, SAMPLE) \\\n"
"	if (CHANNEL == 0) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).r; \\\n"
"	else if (CHANNEL == 1) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).g; \\\n"
"	else if (CHANNEL == 2) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).b; \\\n"
"	else if (CHANNEL == 3) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).a;\n"
"\n"
"inline float NvHair_SampleChannel( Texture2D tex, SamplerState texSampler, float2 texcoords, int channel, float weight = 1.0f)\n"
"{\n"
"	float sample = 1.0f;\n"
"	NV_HAIR_SAMPLE_CHANNEL(tex, texSampler, texcoords, 0, channel, sample);\n"
"	return sample;\n"
"}\n"
"\n"
"#endif // _CPP \n"
"\n"
"#endif  // NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_INTERPOLATE_H\n"
"#define NV_HAIR_INTERPOLATE_H\n"
"\n"
"#ifdef _CPP\n"
"#	error \"Can only be included in HLSL code\"\n"
"#endif\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"#define NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"\n"
"#define NUM_INTERPOLATED_ATTRIBUTES_MINUS_ONE 1023\n"
"#define NUM_INTERPOLATED_ATTRIBUTES 1024\n"
"#define LUT_SIZE_MINUS_ONE 1023\n"
"\n"
"#define NHAIRS_PER_PATCH 64\n"
"#define NSEGMENTS_PER_PATCH 256 \n"
"\n"
"#define TWO_PI 3.141592 * 2.0f\n"
"\n"
"#ifndef FLT_EPSILON\n"
"#define FLT_EPSILON	0.0000001f\n"
"#endif\n"
"\n"
"#ifdef _CPP // C++ code\n"
"\n"
"#define float4			gfsdk_float4\n"
"#define float3			gfsdk_float3\n"
"#define float2			gfsdk_float2\n"
"#define float4x4		gfsdk_float4x4\n"
"#define matrix4			gfsdk_float4x4\n"
"#define DualQuaternion	gfsdk_dualquaternion\n"
"\n"
"typedef int				int2[2];\n"
"typedef int				int4[4];\n"
"\n"
"#define lerp			gfsdk_lerp\n"
"\n"
"#else // shader\n"
"\n"
"struct DualQuaternion\n"
"{\n"
"	float4 q0;\n"
"	float4 q1;\n"
"};\n"
"\n"
"#define matrix4			row_major float4x4\n"
"#define MATERIAL_CHANNELS	float2\n"
"\n"
"inline float NvHair_LerpChannel(float2 channel, float s)\n"
"{\n"
"	return channel.x;\n"
"}\n"
"\n"
"#define SAMPLE_RED(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).r;\n"
"#define SAMPLE_GREEN(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).g;\n"
"#define SAMPLE_BLUE(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).b;\n"
"#define SAMPLE_ALPHA(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).a;\n"
"\n"
"#define NV_HAIR_SAMPLE_CHANNEL(TEX, SAMPLER, TEXCOORD, MIPLEVEL, CHANNEL, SAMPLE) \\\n"
"	if (CHANNEL == 0) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).r; \\\n"
"	else if (CHANNEL == 1) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).g; \\\n"
"	else if (CHANNEL == 2) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).b; \\\n"
"	else if (CHANNEL == 3) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).a;\n"
"\n"
"inline float NvHair_SampleChannel( Texture2D tex, SamplerState texSampler, float2 texcoords, int channel, float weight = 1.0f)\n"
"{\n"
"	float sample = 1.0f;\n"
"	NV_HAIR_SAMPLE_CHANNEL(tex, texSampler, texcoords, 0, channel, sample);\n"
"	return sample;\n"
"}\n"
"\n"
"#endif // _CPP \n"
"\n"
"#endif  // NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_INTERNAL_SHADER_TYPES_H\n"
"#define NV_HAIR_INTERNAL_SHADER_TYPES_H\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"#define NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"\n"
"#define NUM_INTERPOLATED_ATTRIBUTES_MINUS_ONE 1023\n"
"#define NUM_INTERPOLATED_ATTRIBUTES 1024\n"
"#define LUT_SIZE_MINUS_ONE 1023\n"
"\n"
"#define NHAIRS_PER_PATCH 64\n"
"#define NSEGMENTS_PER_PATCH 256 \n"
"\n"
"#define TWO_PI 3.141592 * 2.0f\n"
"\n"
"#ifndef FLT_EPSILON\n"
"#define FLT_EPSILON	0.0000001f\n"
"#endif\n"
"\n"
"#ifdef _CPP // C++ code\n"
"\n"
"#define float4			gfsdk_float4\n"
"#define float3			gfsdk_float3\n"
"#define float2			gfsdk_float2\n"
"#define float4x4		gfsdk_float4x4\n"
"#define matrix4			gfsdk_float4x4\n"
"#define DualQuaternion	gfsdk_dualquaternion\n"
"\n"
"typedef int				int2[2];\n"
"typedef int				int4[4];\n"
"\n"
"#define lerp			gfsdk_lerp\n"
"\n"
"#else // shader\n"
"\n"
"struct DualQuaternion\n"
"{\n"
"	float4 q0;\n"
"	float4 q1;\n"
"};\n"
"\n"
"#define matrix4			row_major float4x4\n"
"#define MATERIAL_CHANNELS	float2\n"
"\n"
"inline float NvHair_LerpChannel(float2 channel, float s)\n"
"{\n"
"	return channel.x;\n"
"}\n"
"\n"
"#define SAMPLE_RED(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).r;\n"
"#define SAMPLE_GREEN(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).g;\n"
"#define SAMPLE_BLUE(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).b;\n"
"#define SAMPLE_ALPHA(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).a;\n"
"\n"
"#define NV_HAIR_SAMPLE_CHANNEL(TEX, SAMPLER, TEXCOORD, MIPLEVEL, CHANNEL, SAMPLE) \\\n"
"	if (CHANNEL == 0) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).r; \\\n"
"	else if (CHANNEL == 1) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).g; \\\n"
"	else if (CHANNEL == 2) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).b; \\\n"
"	else if (CHANNEL == 3) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).a;\n"
"\n"
"inline float NvHair_SampleChannel( Texture2D tex, SamplerState texSampler, float2 texcoords, int channel, float weight = 1.0f)\n"
"{\n"
"	float sample = 1.0f;\n"
"	NV_HAIR_SAMPLE_CHANNEL(tex, texSampler, texcoords, 0, channel, sample);\n"
"	return sample;\n"
"}\n"
"\n"
"#endif // _CPP \n"
"\n"
"#endif  // NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"\n"
"\n"
"#define NV_HAIR_MAX_BONE_MATRICES 256\n"
"\n"
"#define	NV_HAIR_MAX_COLLISION_SPHERES 128\n"
"#define NV_HAIR_MAX_COLLISION_CAPSULES 128\n"
"\n"
"#define	NV_HAIR_MAX_PINS 32\n"
"\n"
"#define NV_HAIR_BLOCK_SIZE_SIMULATE 64\n"
"#define NV_HAIR_BLOCK_SIZE_PIN_COM 1024\n"
"\n"
"\n"
"struct NvHair_SimulationMaterial\n"
"{\n"
"	float		stiffness;\n"
"	float		damping;\n"
"	float		stiffnessStrength;\n"
"	float		stiffnessDamping;\n"
"\n"
"	float		rootStiffness;\n"
"	float		tipStiffness;\n"
"	float		bendStiffness;\n"
"	float		interactionStiffness;\n"
"\n"
"	float		pinStiffness;\n"
"	float		inertiaScale;\n"
"	float		backStopRadius;\n"
"	float		friction;\n"
"\n"
"	float		hairNormalWeight;\n"
"	float		massScale;\n"
"	float		_reserved2_;\n"
"	float		_reserved3_;\n"
"\n"
"	float4		stiffnessCurve;\n"
"	float4		stiffnessStrengthCurve;\n"
"	float4		stiffnessDampingCurve;\n"
"	float4		bendStiffnessCurve;\n"
"	float4		interactionStiffnessCurve;\n"
"};\n"
"\n"
"#define NV_HAIR_LERP_SIMULATION_PARAM(BUFFER, PARAM) \\\n"
"	PARAM	= lerp(BUFFER.defaultMaterial.PARAM, BUFFER.targetMaterial.PARAM, BUFFER.materialWeight);\n"
"\n"
"struct NvHair_SimulateConstantBuffer\n"
"{\n"
"	matrix4 boneMatrices[NV_HAIR_MAX_BONE_MATRICES];\n"
"	matrix4 skinMatrices[NV_HAIR_MAX_BONE_MATRICES];\n"
"	DualQuaternion skinDqs[NV_HAIR_MAX_BONE_MATRICES];\n"
"\n"
"	matrix4 modelToWorld;\n"
"\n"
"	float4 modelCenter;\n"
"	float4 modelCenterRest;\n"
"\n"
"	float4 gravity;\n"
"\n"
"	float3 wind;\n"
"	float windNoise;\n"
"\n"
"	int numBones;\n"
"	int numTotalCvs;\n"
"	int numCollisionSpheres;\n"
"	int numCollisionCapsules;\n"
"\n"
"	int numPinConstraints;\n"
"	int useCollision;\n"
"	int useDynamicPin;\n"
"	int useDualQuaterinon;\n"
"\n"
"	int numTubeVertices; // NUTT\n"
"	int numStrands; // NUTT\n"
"	int numParsPerStrand; // NUTT\n"
"	int numSubSegments; // NUTT\n"
"\n"
"	float kInterpolation; // NUTT\n"
"	float simulationInterp;					///< Used on prepare interp to calculate the simulation interpolation\n"
"	int tmp2;\n"
"	int tmp3;\n"
"\n"
"	int numConstraintIterations;\n"
"	float timeStep;\n"
"	int simulate;\n"
"	int lockInertia;\n"
"\n"
"	float maxHairLength;\n"
"	int stiffnessChannel;\n"
"	int rootStiffnessChannel;\n"
"	float _reserved3_;\n"
"\n"
"	int useStiffnessTexture;\n"
"	int useRootStiffnessTexture;\n"
"	int useWeightTexture;\n"
"	float materialWeight;\n"
"\n"
"	NvHair_SimulationMaterial defaultMaterial;\n"
"	NvHair_SimulationMaterial targetMaterial;\n"
"\n"
"	float4 collisionSpheres[NV_HAIR_MAX_COLLISION_SPHERES];\n"
"	float4 collisionCapsuleIndex[NV_HAIR_MAX_COLLISION_CAPSULES];\n"
"};\n"
"\n"
"\n"
"struct NvHair_TessellationMaterial // packed to 2 channel for faster sampling/interpolation\n"
"{\n"
"	float		width;\n"
"	float		widthNoiseScale;\n"
"	float		rootWidthScale;\n"
"	float		tipWidthScale;\n"
"\n"
"	float		density;\n"
"	float		clumpScale;\n"
"	float		clumpNoise;\n"
"	float		clumpRoundness;\n"
"\n"
"	float		lengthNoise;\n"
"	float		lengthScale;\n"
"	float		__reserved1__;\n"
"	float		__reserved2__;\n"
"\n"
"	float		waveScale;\n"
"	float		waveScaleNoise;\n"
"	float		waveScaleStrand;\n"
"	float		waveScaleClump;\n"
"\n"
"	float		waveFreq;\n"
"	float		waveFreqNoise;\n"
"	float		waveCutoff;\n"
"	float		__reserved3__;\n"
"};\n"
"\n"
"struct NvHair_TessellationConstantBuffer\n"
"{\n"
"	// transforms\n"
"	matrix4	viewProjection;\n"
"	matrix4	viewMatrix;\n"
"	matrix4	inverseViewMatrix;\n"
"	matrix4	modelToWorld;\n"
"	matrix4	cullSphereInvTransform;\n"
"	float4 camPosition;\n"
"\n"
"	// tessellation materials\n"
"	NvHair_TessellationMaterial defaultMaterial;\n"
"	NvHair_TessellationMaterial targetMaterial;\n"
"\n"
"	// texture bit\n"
"	int useDensityTexture;\n"
"	int	useWidthTexture;\n"
"	int	useClumpScaleTexture;\n"
"	int useClumpRoundnessTexture;\n"
"\n"
"	int useClumpNoiseTexture;\n"
"	int useWaveScaleTexture;\n"
"	int useWaveFreqTexture;\n"
"	int useLengthTexture;\n"
"\n"
"	// material control\n"
"	float materialWeight;\n"
"	int useWeightTexture;\n"
"	unsigned int strandPointCount;\n"
"	float __reserved1__;\n"
"\n"
"	// shader settings\n"
"	unsigned int shaderMask;\n"
"	int leftHanded;\n"
"	int vertexClumping;\n"
"	float __reserved2_;\n"
"\n"
"	// density option\n"
"	int usePixelDensity;\n"
"	float densityPass;\n"
"	float __reserved3__;\n"
"	float __reserved2__;\n"
"\n"
"	// culling\n"
"	int useViewfrustrumCulling;\n"
"	float useBackfaceCulling;\n"
"	float backfaceCullingThreshold;\n"
"	int useCullSphere;\n"
"\n"
"	// channels\n"
"	int2 densityTextureChan;\n"
"	int2 widthTextureChan;\n"
"\n"
"	int2 clumpScaleTextureChan;\n"
"	int2 clumpRoundnessTextureChan;\n"
"\n"
"	int2 waveScaleTextureChan;\n"
"	int2 waveFreqTextureChan;\n"
"\n"
"	int2 lengthTextureChan;\n"
"	int2 weightTextureChan;\n"
"\n"
"	// Cubemap rendering info\n"
"	int4 cubeMapActive;\n"
"	matrix4	cubeMapViewProjMatrix[6];\n"
"	matrix4	cubeMapInvViewMatrix[6];\n"
"	int4 cubeMapVisible[6];\n"
"};\n"
"\n"
"\n"
"struct NvHair_Pin\n"
"{\n"
"	matrix4 invHairPoseMatrix;\n"
"	matrix4 currentHairMatrix;\n"
"\n"
"	matrix4 invPinPoseMatrix; // = inverse pose\n"
"	matrix4 currentPinMatrix;\n"
"	matrix4 shapeMatrix;\n"
"\n"
"	float radius;\n"
"	float3 localPos;\n"
"\n"
"	int boneIndex;\n"
"	float3 restComShift;\n"
"\n"
"	int rootBoneIndex;\n"
"	float rootBoneDis;\n"
"	int stiffPin;\n"
"	int doLra;\n"
"\n"
"	float3 restTangent;\n"
"	int useDynamicPin;\n"
"\n"
"	float stiffness;\n"
"	float influenceFallOff;\n"
"	int selected;\n"
"	float __align__;\n"
"\n"
"	float4 influenceFallOffCurve;\n"
"};\n"
"\n"
"#define NV_HAIR_SCRATCH_SIZE_PER_PIN 128 // = 128 * 1024 = 130K simulated CVs\n"
"struct NvHair_PinScratchData\n"
"{\n"
"	float4 com;\n"
"	float4 tangent;\n"
"};\n"
"\n"
"\n"
"struct NvHair_SplineConstantBuffer\n"
"{\n"
"	matrix4 modelToWorld;\n"
"\n"
"	unsigned int numVertsPerSegments;\n"
"	unsigned int numMasterSegments;\n"
"	unsigned int numTessellatedPoints;\n"
"	unsigned int strandPointCounts;\n"
"\n"
"	float simulationInterp;\n"
"	float __unused__[3];\n"
"};\n"
"\n"
"\n"
"struct NvHair_VisualizeConstantBuffer\n"
"{\n"
"	matrix4 viewProjection;\n"
"	matrix4 modelToWorld;\n"
"\n"
"	float4 color;\n"
"\n"
"	int hairMin;\n"
"	int hairMax;\n"
"	int hairSkip;\n"
"	int hairDummy;\n"
"\n"
"	float hairWidth;\n"
"	float aspect;\n"
"	float scale;\n"
"	int pinId;\n"
"};\n"
"\n"
"\n"
"struct NvHair_StatsPerFrameConstantBuffer\n"
"{\n"
"	int		numFaces;\n"
"	int		usePixelDensity;\n"
"	float	density;\n"
"	int		_dummy;\n"
"};\n"
"\n"
"\n"
"#endif  // NV_HAIR_INTERNAL_SHADER_TYPES_H\n"
"\n"
"\n"
"void NvHair_BlendMaterial(NvHair_TessellationMaterial defaultMaterial, in NvHair_TessellationMaterial targetMaterial, float weight, out NvHair_TessellationMaterial dst)\n"
"{\n"
"#define LERP_MATERIAL(PARAM) \\\n"
"	dst.PARAM	= lerp(defaultMaterial.PARAM, targetMaterial.PARAM, weight);\n"
"\n"
"	LERP_MATERIAL(width);\n"
"	LERP_MATERIAL(widthNoiseScale);\n"
"	LERP_MATERIAL(rootWidthScale);\n"
"	LERP_MATERIAL(tipWidthScale);\n"
"\n"
"	LERP_MATERIAL(density);\n"
"	LERP_MATERIAL(clumpScale);\n"
"	LERP_MATERIAL(clumpNoise);\n"
"	LERP_MATERIAL(clumpRoundness);\n"
"\n"
"	LERP_MATERIAL(lengthNoise);\n"
"	LERP_MATERIAL(lengthScale);\n"
"	LERP_MATERIAL(waveScale);\n"
"	LERP_MATERIAL(waveFreq);\n"
"\n"
"	LERP_MATERIAL(waveScaleNoise);\n"
"	LERP_MATERIAL(waveFreqNoise);\n"
"	LERP_MATERIAL(waveCutoff);\n"
"	LERP_MATERIAL(waveScaleClump);\n"
"	LERP_MATERIAL(waveScaleStrand);\n"
"\n"
"#undef LERP_MATERIAL\n"
"}\n"
"\n"
"Buffer<float4>				g_tessellatedMasterStrand		: register(t0);\n"
"Buffer<float4>				g_tessellatedMasterStrandPrev	: register(t1);\n"
"\n"
"Buffer<float4>				g_restMasterStrand				: register(t2);\n"
"Buffer<float2>				g_texCoords						: register(t3);\n"
"\n"
"Buffer<float3>				g_faceHairIndices				: register(t4);\n"
"Buffer<float2>				g_strandCoordinatesLut			: register(t5);\n"
"Buffer<float>				g_noiseLut						: register(t6);\n"
"\n"
"Texture2D					g_densityTexture				: register(t7);\n"
"Texture2D					g_widthTexture					: register(t8);\n"
"\n"
"Texture2D					g_clumpScaleTexture				: register(t9);\n"
"Texture2D					g_clumpRoundnessTexture			: register(t10);\n"
"\n"
"Texture2D					g_waveScaleTexture				: register(t11);\n"
"Texture2D					g_waveFreqTexture				: register(t12);\n"
"Texture2D					g_lengthTexture					: register(t13);\n"
"Texture2D					g_weightTexture					: register(t14);\n"
"\n"
"Buffer<float4>				g_tessellatedTangents			: register(t15);\n"
"Buffer<float4>				g_tessellatedNormals			: register(t16);\n"
" \n"
"SamplerState samLinear : register(s0);\n"
"SamplerState samPointClamp : register(s1);\n"
"\n"
"cbuffer cbPerFrame : register( b0 )\n"
"{\n"
"	NvHair_TessellationConstantBuffer g_buffer;\n"
"}\n"
"\n"
"struct VSOut\n"
"{\n"
"	float dummy : DUMMY;\n"
"};\n"
"\n"
"struct HSOut\n"
"{\n"
"    float		edges[2]			: SV_TessFactor;\n"
"	float3		rootIndices			: ROOT_INDICES;\n"
"	float3x2	texcoords			: TEX_COORDS;\n"
"	uint		primitiveId			: PRIMITIVE_ID;\n"
"};\n"
"\n"
"struct DSOut // 14 floats\n"
"{\n"
"   float3	position	: Position;\n"
"   float2	texcoords	: SCALPTEX;\n"
"   float3	normal		: Normal;\n"
"   float3	tangent		: Tangent;\n"
"   float	width		: Width;\n"
"   float	tex			: TEXALONGLENGTH;\n"
"\n"
"   uint		primitiveId : PRIMITIVE_ID;\n"
"   float2	coords		: COORDS;\n"
"};\n"
"\n"
"inline float NvHair_SampleMultiChannel( Texture2D tex, float2 texcoords, int2 channels, float weight)\n"
"{\n"
"#if MULTI_CHANNEL_SUPPORT\n"
"	float sampleDefault = 1.0f;\n"
"	float sampleTarget = 1.0f;\n"
"	float sample = 1.0f;\n"
"\n"
"	NV_HAIR_SAMPLE_CHANNEL(tex, samLinear, texcoords, 0, channels[0], sampleDefault);\n"
"	NV_HAIR_SAMPLE_CHANNEL(tex, samLinear, texcoords, 0, channels[1], sampleTarget); // optimize?\n"
"\n"
"	if (weight == 0.0f)\n"
"		sample = sampleDefault;\n"
"	else\n"
"	{\n"
"		sample = lerp(sampleDefault, sampleTarget, weight);\n"
"	}\n"
"#else\n"
"	float sample = 1.0f;\n"
"\n"
"	NV_HAIR_SAMPLE_CHANNEL(tex, samLinear, texcoords, 0, channels[0], sample);\n"
"#endif\n"
"\n"
"	return sample;\n"
"}\n"
"\n"
"inline void NvHair_BlendMaterial(out NvHair_TessellationMaterial material, float weight = 0.0f)\n"
"{\n"
"	material = g_buffer.defaultMaterial;\n"
"}\n"
"\n"
"\n"
"inline float3 NvHair_InterpolateBary(float3 v0, float3 v1, float3 v2, float3 coords)\n"
"{\n"
"	return coords.x  * v0.xyz + coords.y * v1.xyz + coords.z * v2.xyz; \n"
"}\n"
"\n"
"inline float4 NvHair_InterpolateBary(float4 v0, float4 v1, float4 v2, float3 coords)\n"
"{\n"
"	return coords.x  * v0 + coords.y * v1 + coords.z * v2; \n"
"}\n"
"\n"
"float packFloat2(float x, float y)\n"
"{\n"
"	const float base = 2048;\n"
"\n"
"	float basey = floor(base * y);\n"
"	float packed = basey + x;\n"
"\n"
"	return packed;\n"
"}\n"
"\n"
"float packSignedFloat(float x)\n"
"{\n"
"	return 0.5f + 0.5f * clamp(x, -1.0, 1.0);\n"
"}\n"
"\n"
"float packSignedFloat2(float x, float y)\n"
"{\n"
"	float sx = packSignedFloat(x);\n"
"	float sy = packSignedFloat(y);\n"
"\n"
"	return packFloat2(sx,sy);\n"
"}\n"
"\n"
"\n"
"inline float2 unpackFloat2(float packed)\n"
"{\n"
"	const float inv_base = 1.0f / 2048.0f;\n"
"\n"
"	float ubase = floor(packed);\n"
"	float unpackedy = ubase * inv_base;\n"
"	float unpackedx = packed - ubase;\n"
"\n"
"	return float2(unpackedx, unpackedy);\n"
"}\n"
"\n"
"inline float unpackSignedFloat(float x)\n"
"{\n"
"	return clamp(2.0f * (x - 0.5f), -1.0f, 1.0f);\n"
"}\n"
"\n"
"inline float2 unpackSignedFloat2(float x)\n"
"{\n"
"	float2 unpacked = unpackFloat2(x);\n"
"	float sx = unpackSignedFloat(unpacked.x);\n"
"	float sy = unpackSignedFloat(unpacked.y);\n"
"\n"
"	return float2(sx, sy);\n"
"}\n"
"\n"
"float3 NvHair_GetCameraDirection()\n"
"{\n"
"	//float3 dir = gfsdk_getBasisZ(g_buffer.inverseViewMatrix);\n"
"	float3 dir = float3(\n"
"		g_buffer.inverseViewMatrix._31,\n"
"		g_buffer.inverseViewMatrix._32,\n"
"		g_buffer.inverseViewMatrix._33);\n"
"\n"
"	if (g_buffer.leftHanded)\n"
"		dir *= -1;\n"
"\n"
"	return dir;\n"
"}\n"
"\n"
"#endif  // NV_HAIR_INTERPOLATE_H\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_SHADER_COMMON_H\n"
"#define NV_HAIR_SHADER_COMMON_H\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_SHADER_COMMON_TYPES_H\n"
"#define NV_HAIR_SHADER_COMMON_TYPES_H\n"
"\n"
"#ifdef _CPP \n"
"#	include \"NvHairShaderCpp.h\"\n"
"#endif\n"
"\n"
"struct NvHair_ShaderAttributes\n"
"{\n"
"	float3	P;			// world coord position\n"
"	float3	T;			// world space tangent vector\n"
"	float3	N;			// world space normal vector at the root\n"
"	float4	texcoords; // texture coordinates on hair root \n"
"						// .xy: texcoord on the hair root\n"
"						// .z: texcoord along the hair\n"
"						// .w: texcoord along the hair quad\n"
"	float3	V;			// world space view vector\n"
"	float	hairID;		// unique hair identifier\n"
"\n"
"#if defined(NV_HAIR_DECLARE_VELOCITY_ATTR)\n"
"	float3	wVel;		// 'pixel velocity'. In view space, difference current pixel position, and previous pixel position. W is W after view projection. Look at NvHair_WorldToScreen for details.\n"
"#endif\n"
"};\n"
"\n"
"struct NvHair_Material \n"
"{\n"
"	// 3 float4\n"
"	float4			rootColor; \n"
"	float4			tipColor; \n"
"	float4			specularColor; \n"
"\n"
"	// 4 floats (= 1 float4)\n"
"	float			diffuseBlend;\n"
"	float			diffuseScale;\n"
"	float			diffuseHairNormalWeight;\n"
"	float			_diffuseUnused_; // for alignment and future use\n"
"\n"
"	// 4 floats (= 1 float4)\n"
"	float			specularPrimaryScale;\n"
"	float			specularPrimaryPower;\n"
"	float			specularPrimaryBreakup;\n"
"	float			specularNoiseScale;\n"
"\n"
"	// 4 floats (= 1 float4)\n"
"	float			specularSecondaryScale;\n"
"	float			specularSecondaryPower;\n"
"	float			specularSecondaryOffset;\n"
"	float			_specularUnused_; // for alignment and future use\n"
"\n"
"	// 4 floats (= 1 float4)\n"
"	float			rootTipColorWeight;\n"
"	float			rootTipColorFalloff;\n"
"	float			shadowSigma;\n"
"	float			strandBlendScale;\n"
"\n"
"	// 4 floats (= 1 float4)\n"
"	float			glintStrength;\n"
"	float			glintCount;\n"
"	float			glintExponent;\n"
"	float			rootAlphaFalloff;\n"
"};\n"
"\n"
"struct NvHair_ConstantBuffer\n"
"{\n"
"	static const int NOISE_TABLE_SIZE = 64;\n"
"\n"
"	// camera information \n"
"	row_major	float4x4	inverseViewProjection; // inverse of view projection matrix\n"
"	row_major	float4x4	inverseProjection; // inverse of projection matrix\n"
"	row_major	float4x4	inverseViewport; // inverse of viewport transform\n"
"	row_major	float4x4	inverseViewProjectionViewport; // inverse of world to screen matrix\n"
"\n"
"	row_major	float4x4	viewProjection; // view projection matrix\n"
"	row_major	float4x4	viewport; // viewport matrix\n"
"\n"
"	row_major	float4x4	prevViewProjection; // previous view projection matrix for pixel velocity computation\n"
"	row_major	float4x4	prevViewport; // previous viewport matrix for pixel velocity computation\n"
"\n"
"	float4			camPosition;		  // position of camera center\n"
"	float4			modelCenter; // center of the growth mesh model\n"
"\n"
"	// shared settings \n"
"	int				useRootColorTexture;\n"
"	int				useTipColorTexture; \n"
"	int				useStrandTexture;\n"
"	int				useSpecularTexture;\n"
"\n"
"	int				receiveShadows;		\n"
"	int				shadowUseLeftHanded;\n"
"	float			__shadowReserved1__;\n"
"	float			__shadowReserved2__;\n"
"\n"
"	int				strandBlendMode;\n"
"	int				colorizeMode;	\n"
"	int				strandPointCount;\n"
"	int				__reserved__;\n"
"\n"
"	float			lodDistanceFactor;		\n"
"	float			lodDetailFactor;		\n"
"	float			lodAlphaFactor;\n"
"	float			__reservedLOD___;\n"
"\n"
"\n"
"	NvHair_Material	defaultMaterial; \n"
"\n"
"	// noise table\n"
"	float4			noiseTable[NOISE_TABLE_SIZE]; // 256 floats\n"
"};\n"
"\n"
"#endif // NV_HAIR_SHADER_COMMON_TYPES_H\n"
"\n"
"#ifdef _CPP\n"
"#	error \"Can only be included in HLSL\"\n"
"#endif\n"
"\n"
"#ifndef SAMPLE_LEVEL\n"
"#define SAMPLE_LEVEL( _texture, _sampler, _coord, _level )	_texture.SampleLevel( _sampler, _coord, _level )\n"
"#endif\n"
"\n"
"#ifndef SYS_POSITION\n"
"#define SYS_POSITION					SV_Position\n"
"#endif\n"
"\n"
"#ifndef NOINTERPOLATION\n"
"#define	NOINTERPOLATION					nointerpolation\n"
"#endif\n"
"\n"
"float NvHair_GetNormalizedNoise(unsigned int hash, NvHair_ConstantBuffer hairConstantBuffer)\n"
"{\n"
"	unsigned int id = hash % (NvHair_ConstantBuffer::NOISE_TABLE_SIZE * 4);\n"
"\n"
"	unsigned int noiseIdx1 = id / 4;\n"
"	unsigned int noiseIdx2 = id % 4;\n"
"\n"
"	return hairConstantBuffer.noiseTable[noiseIdx1][noiseIdx2];\n"
"}\n"
"\n"
"float NvHair_GetSignedNoise(unsigned int hash, NvHair_ConstantBuffer hairConstantBuffer)\n"
"{\n"
"	float v = NvHair_GetNormalizedNoise(hash, hairConstantBuffer);\n"
"	return 2.0f * (v - 0.5f);\n"
"}\n"
"\n"
"float3 NvHair_GetVectorNoise(unsigned int seed, NvHair_ConstantBuffer hairConstantBuffer)\n"
"{\n"
"	float x = NvHair_GetSignedNoise(seed, hairConstantBuffer);\n"
"	float y = NvHair_GetSignedNoise(seed + 1229, hairConstantBuffer);\n"
"	float z = NvHair_GetSignedNoise(seed + 2131, hairConstantBuffer);\n"
"\n"
"	return float3(x,y,z);\n"
"}\n"
"\n"
"float3 NvHair_ComputeHairShading(\n"
"	float3 Lcolor, // light color and illumination\n"
"	float3 Ldir, // light direction\n"
"\n"
"	float3 V, // view vector\n"
"	float3 N, // surface normal\n"
"	float3 T, // hair tangent\n"
"\n"
"	float3 diffuseColor, // diffuse albedo\n"
"	float3 specularColor, // specularity\n"
"\n"
"	float diffuseBlend,\n"
"	float primaryScale,\n"
"	float primaryShininess,\n"
"	float secondaryScale,\n"
"	float secondaryShininess,\n"
"	float secondaryOffset\n"
"	)\n"
"{\n"
"	// diffuse hair shading\n"
"	float TdotL = clamp(dot( T , Ldir), -1.0f, 1.0f);\n"
"	float diffuseSkin = max(0, dot( N, Ldir));\n"
"	float diffuseHair = sqrt( 1.0f - TdotL*TdotL );\n"
"	\n"
"	float diffuseSum = lerp(diffuseHair, diffuseSkin, diffuseBlend);\n"
"	\n"
"	// primary specular\n"
"	float3 H = normalize(V + Ldir);\n"
"	float TdotH = clamp(dot(T, H), -1.0f, 1.0f);\n"
"	float specPrimary = sqrt(1.0f - TdotH*TdotH);\n"
"	specPrimary = pow(max(0, specPrimary), primaryShininess);\n"
"\n"
"	// secondary\n"
"	TdotH = clamp(TdotH + secondaryOffset, -1.0, 1.0);\n"
"	float specSecondary = sqrt(1 - TdotH*TdotH);\n"
"	specSecondary = pow(max(0, specSecondary), secondaryShininess);\n"
"\n"
"	// specular sum\n"
"	float specularSum = primaryScale * specPrimary + secondaryScale * specSecondary;\n"
"\n"
"	float3 output = diffuseSum * (Lcolor * diffuseColor) + specularSum * (Lcolor * specularColor);\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"float3 NvHair_ComputeHairShading(\n"
"	float3						Lcolor,\n"
"	float3						Ldir,\n"
"	NvHair_ShaderAttributes	attr,\n"
"	NvHair_Material			mat,\n"
"	float3						hairColor\n"
"	)\n"
"{\n"
"	return NvHair_ComputeHairShading(\n"
"		Lcolor, Ldir,\n"
"		attr.V, attr.N, attr.T,\n"
"		hairColor,\n"
"		mat.specularColor.rgb,\n"
"		mat.diffuseBlend,\n"
"		mat.specularPrimaryScale,\n"
"		mat.specularPrimaryPower,\n"
"		mat.specularSecondaryScale,\n"
"		mat.specularSecondaryPower,\n"
"		mat.specularSecondaryOffset);\n"
"}\n"
"\n"
"float NvHair_SampleBilinear(\n"
"	float val00, float val10, float val01, float val11, float u, float v)\n"
"{\n"
"	float val0 = lerp(val00, val10, u);\n"
"	float val1 = lerp(val01, val11, u);\n"
"	float val  = lerp(val0, val1, v);\n"
"	return val;\n"
"}\n"
"\n"
"float NvHair_ComputeStructuredNoise(\n"
"	float						noiseCount,\n"
"	float						seed,\n"
"	NvHair_ConstantBuffer	hairConstantBuffer\n"
")\n"
"{\n"
"	// seed along hair length\n"
"	float hash = noiseCount * seed;\n"
"	float noiseSeed = floor(hash);\n"
"	float noiseFrac = hash - noiseSeed - 0.5f;\n"
"	\n"
"	// seed for neighboring sample\n"
"	float seedNeighbor = (noiseFrac < 0) ? noiseSeed - 1.0f : noiseSeed + 1.0f;\n"
"	seedNeighbor = max(0, seedNeighbor);\n"
"\n"
"	// sample 4 noise values for bilinear interpolation\n"
"	float seedSample0 = noiseSeed;\n"
"	float seedSample1 = seedNeighbor;\n"
"\n"
"	float noise0 = NvHair_GetNormalizedNoise(seedSample0, hairConstantBuffer);\n"
"	float noise1 = NvHair_GetNormalizedNoise(seedSample1, hairConstantBuffer);\n"
"\n"
"	// interpolated noise sample\n"
"	float noise = lerp(noise0, noise1, abs(noiseFrac));\n"
"\n"
"	// scale noise by user param\n"
"	return noise;\n"
"}\n"
"\n"
"float NvHair_ComputeHairGlint(\n"
"	NvHair_ConstantBuffer	hairConstantBuffer,\n"
"	NvHair_Material			mat,\n"
"	NvHair_ShaderAttributes	attr\n"
")\n"
"{\n"
"	// read material parameters\n"
"	float glintSize			= mat.glintCount;\n"
"	float glintPower		= mat.glintExponent;\n"
"\n"
"	// seed along hair length\n"
"	float lengthHash = glintSize * attr.texcoords.z;\n"
"	float lengthSeed = floor(lengthHash);\n"
"	float lengthFrac = lengthHash - lengthSeed - 0.5f;\n"
"	\n"
"	// seed for neighboring sample\n"
"	float lengthSeedNeighbor = (lengthFrac < 0) ? lengthSeed - 1.0f : lengthSeed + 1.0f;\n"
"	lengthSeedNeighbor = max(0, lengthSeedNeighbor);\n"
"\n"
"	// sample 4 noise values for bilinear interpolation\n"
"	float seedSample0 = attr.hairID + lengthSeed;\n"
"	float seedSample1 = attr.hairID + lengthSeedNeighbor;\n"
"\n"
"	float noise0 = NvHair_GetNormalizedNoise(seedSample0, hairConstantBuffer);\n"
"	float noise1 = NvHair_GetNormalizedNoise(seedSample1, hairConstantBuffer);\n"
"\n"
"	// interpolated noise sample\n"
"	float noise = lerp(noise0, noise1, abs(lengthFrac));\n"
"\n"
"	// apply gamma like power function\n"
"	noise = pow(noise, glintPower);\n"
"\n"
"	// scale noise by user param\n"
"	return noise;\n"
"}\n"
"\n"
"float NvHair_ComputeHairDiffuseShading(\n"
"	float3		Ldir, // light direction\n"
"	float3		T,\n"
"	float3		N,\n"
"	float		diffuseScale,\n"
"	float		diffuseBlend\n"
"	)\n"
"{\n"
"	// diffuse hair shading\n"
"	float TdotL = clamp(dot( T , Ldir), -1.0f, 1.0f);\n"
"\n"
"	float diffuseSkin = max(0, dot( N, Ldir));\n"
"	float diffuseHair = sqrt( 1.0f - TdotL*TdotL );\n"
"\n"
"	float diffuse = lerp(diffuseHair, diffuseSkin, diffuseBlend);\n"
"	float result = diffuseScale * saturate(diffuse);\n"
"\n"
"	return max(0,result);\n"
"}\n"
"\n"
"void NvHair_ApplyGlint(const float glintScale, const float glint, const float3 lightColor, inout float3 ambientInOut, inout float specularInOut)\n"
"{\n"
"	// Glint scale is typically 'mat.glintStrength'. If it is <=0 then this method should not be applied\n"
"	// Apply to ambient\n"
"	float luminance = dot(lightColor, float3(0.3, 0.5, 0.2));\n"
"	ambientInOut += glintScale * glint * float3(luminance, luminance, luminance);\n"
"	// Apply to specular\n"
"	specularInOut *= lerp(1.0f, glint, glintScale);\n"
"}\n"
"\n"
"float3 NvHair_ComputeHairShadingWithGlint(\n"
"	float3 lightColor, // light color and illumination\n"
"	float3 lightDir, // light direction\n"
"	float3 lightAmbient,\n"
"\n"
"	float3 V, // view vector\n"
"	float3 N, // surface normal\n"
"	float3 T, // hair tangent\n"
"\n"
"	float3 diffuseColor, // diffuse albedo\n"
"	float3 specularColor, // specularity\n"
"\n"
"	float diffuseBlend,\n"
"	float primaryScale,\n"
"	float primaryShininess,\n"
"	float secondaryScale,\n"
"	float secondaryShininess,\n"
"	float secondaryOffset,\n"
"\n"
"	float glintScale, \n"
"	float glint	\n"
"	)\n"
"{\n"
"	// diffuse hair shading\n"
"	float TdotL = clamp(dot(T, lightDir), -1.0f, 1.0f);\n"
"	float diffuseSkin = max(0, dot(N, lightDir));\n"
"	float diffuseHair = sqrt(1.0f - TdotL*TdotL);\n"
"\n"
"	float diffuseSum = lerp(diffuseHair, diffuseSkin, diffuseBlend);\n"
"\n"
"	// primary specular\n"
"	float3 H = normalize(V + lightDir);\n"
"	float TdotH = clamp(dot(T, H), -1.0f, 1.0f);\n"
"	float specPrimary = sqrt(1.0f - TdotH*TdotH);\n"
"	specPrimary = pow(max(0, specPrimary), primaryShininess);\n"
"\n"
"	// secondary\n"
"	TdotH = clamp(TdotH + secondaryOffset, -1.0, 1.0);\n"
"	float specSecondary = sqrt(1 - TdotH*TdotH);\n"
"	specSecondary = pow(max(0, specSecondary), secondaryShininess);\n"
"\n"
"	// specular sum\n"
"	float specularSum = primaryScale * specPrimary + secondaryScale * specSecondary;\n"
"	\n"
"	float3 ambient = lightAmbient;\n"
"	\n"
"	if (glintScale > 0.0f)\n"
"	{\n"
"		NvHair_ApplyGlint(glintScale, glint, lightColor, ambient, specularSum);\n"
"	}\n"
"\n"
"	float3 output = (ambient + diffuseSum * lightColor )* diffuseColor + specularSum * (lightColor * specularColor);\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"float3 NvHair_ComputeHairShadingWithGlint(float3 lightColor, float3 lightDir, float3 lightAmbient, NvHair_ShaderAttributes attr, NvHair_Material mat, float3 hairColor, float glint)\n"
"{\n"
"	return NvHair_ComputeHairShadingWithGlint(\n"
"		lightColor, lightDir, lightAmbient,\n"
"		attr.V, attr.N, attr.T,\n"
"		hairColor, mat.specularColor.rgb,\n"
"		mat.diffuseBlend,\n"
"		mat.specularPrimaryScale, mat.specularPrimaryPower, mat.specularSecondaryScale, mat.specularSecondaryPower, mat.specularSecondaryOffset, \n"
"		mat.glintStrength, glint);\n"
"}\n"
"\n"
"float NvHair_ComputeHairSpecularShading(\n"
"	float		hairID,\n"
"\n"
"	float3		Ldir, \n"
"	float3		V,\n"
"	float3		T,\n"
"	float3		N,\n"
"\n"
"	float		primaryScale,\n"
"	float		primaryShininess,\n"
"	float		secondaryScale,\n"
"	float		secondaryShininess,\n"
"	float		secondaryOffset,\n"
"	float		diffuseBlend,\n"
"\n"
"	float		primaryBreakup = 0.0f\n"
"	)\n"
"{\n"
"	uint	hash = asuint(hairID * 17938401.0f);\n"
"	float	noiseVal = float(hash % 1024) / 1024.0f;\n"
"	float	signedNoise = noiseVal - 0.5f;\n"
"\n"
"	float specPrimaryOffset = primaryBreakup * signedNoise;\n"
"\n"
"	// primary specular\n"
"	float3 H				= normalize(V + Ldir);\n"
"	float TdotH				= clamp(dot(T, H), -1.0f, 1.0f);\n"
"\n"
"	float TdotHshifted		= clamp(TdotH + specPrimaryOffset, -1.0f, 1.0f);\n"
"	float specPrimary		= sqrt(1.0f - TdotHshifted*TdotHshifted);\n"
"\n"
"	specPrimary				= pow(max(0, specPrimary), primaryShininess);\n"
"\n"
"	// secondary\n"
"	TdotH					= clamp(TdotH + secondaryOffset, -1.0, 1.0);\n"
"	float specSecondary		= sqrt(1 - TdotH*TdotH);\n"
"	specSecondary			= pow(max(0, specSecondary), secondaryShininess);\n"
"\n"
"	// specular sum\n"
"	float specularSum = primaryScale * specPrimary + secondaryScale * specSecondary;\n"
"\n"
"	// visibility due to diffuse normal\n"
"	float visibilityScale = lerp(1.0f, saturate(dot(N, Ldir)), diffuseBlend);\n"
"	specularSum *= visibilityScale;\n"
"\n"
"	return max(0,specularSum);\n"
"}\n"
"\n"
"float NvHair_ComputeHairSpecularShading(\n"
"	float3 Ldir, // light direction\n"
"	NvHair_ShaderAttributes	attr,\n"
"	NvHair_Material			mat)\n"
"{\n"
"	return  NvHair_ComputeHairSpecularShading(\n"
"		attr.hairID,\n"
"		Ldir,\n"
"		attr.V, attr.T, attr.N,\n"
"		mat.specularPrimaryScale,\n"
"		mat.specularPrimaryPower,\n"
"		mat.specularSecondaryScale,\n"
"		mat.specularSecondaryPower,\n"
"		mat.specularSecondaryOffset,\n"
"		mat.diffuseBlend,\n"
"		mat.specularPrimaryBreakup\n"
"		);\n"
"}\n"
"\n"
"float NvHair_GetRootTipRatio(const float s, NvHair_Material mat)\n"
"{\n"
"	float ratio = s;\n"
"\n"
"	// add bias for root/tip color variation\n"
"	if (mat.rootTipColorWeight < 0.5f)\n"
"	{\n"
"		float slope = 2.0f * mat.rootTipColorWeight;\n"
"		ratio = slope * ratio;\n"
"	}\n"
"	else\n"
"	{\n"
"		float slope = 2.0f * (1.0f - mat.rootTipColorWeight) ;\n"
"		ratio = slope * (ratio - 1.0f) + 1.0f;\n"
"	}\n"
"\n"
"	// modify ratio for falloff\n"
"	float slope = 1.0f / (mat.rootTipColorFalloff + 0.001f);\n"
"	ratio = saturate(0.5f + slope * (ratio - 0.5f));\n"
"\n"
"	return ratio;\n"
"}\n"
"\n"
"float3 NvHair_SampleHairColorTex(\n"
"	NvHair_ConstantBuffer	hairConstantBuffer,\n"
"	NvHair_Material			mat, \n"
"	SamplerState				texSampler, \n"
"	Texture2D					rootColorTex, \n"
"	Texture2D					tipColorTex, \n"
"	float3						texcoords)\n"
"{\n"
"	float3 rootColor = mat.rootColor.rgb;\n"
"	float3 tipColor = mat.tipColor.rgb;\n"
"\n"
"	if (hairConstantBuffer.useRootColorTexture)\n"
"		rootColor = (SAMPLE_LEVEL( rootColorTex, texSampler, texcoords.xy, 0 )).rgb;  \n"
"	if (hairConstantBuffer.useTipColorTexture)\n"
"		tipColor = (SAMPLE_LEVEL( tipColorTex, texSampler, texcoords.xy, 0 )).rgb;  \n"
"\n"
"	float ratio = NvHair_GetRootTipRatio(texcoords.z, mat);\n"
"\n"
"	float3 hairColor = lerp(rootColor, tipColor, ratio);\n"
"\n"
"	return hairColor;\n"
"}\n"
"\n"
"float3 NvHair_SampleHairColorStrandTex(\n"
"	NvHair_ConstantBuffer	hairConstantBuffer,\n"
"	NvHair_Material			mat, \n"
"	SamplerState				texSampler, \n"
"	Texture2D					rootColorTex, \n"
"	Texture2D					tipColorTex, \n"
"	Texture2D					strandColorTex, \n"
"	float4						texcoords)\n"
"{\n"
"	float3 rootColor = mat.rootColor.rgb;\n"
"	float3 tipColor = mat.tipColor.rgb;\n"
"\n"
"	if (hairConstantBuffer.useRootColorTexture)\n"
"		rootColor = (SAMPLE_LEVEL( rootColorTex, texSampler, texcoords.xy, 0 )).rgb;  \n"
"	if (hairConstantBuffer.useTipColorTexture)\n"
"		tipColor = (SAMPLE_LEVEL( tipColorTex, texSampler, texcoords.xy, 0 )).rgb;  \n"
"\n"
"	float ratio = NvHair_GetRootTipRatio(texcoords.z, mat);\n"
"\n"
"	float3 hairColor = lerp(rootColor, tipColor, ratio);\n"
"\n"
"	if (hairConstantBuffer.useStrandTexture)\n"
"	{\n"
"		float3 strandColor = (SAMPLE_LEVEL( strandColorTex, texSampler, texcoords.zw, 0 )).rgb;  \n"
"\n"
"		switch(hairConstantBuffer.strandBlendMode)\n"
"		{\n"
"			case 0:\n"
"				hairColor = mat.strandBlendScale * strandColor;\n"
"				break;\n"
"			case 1:\n"
"				hairColor = lerp(hairColor, hairColor * strandColor, mat.strandBlendScale);\n"
"				break;\n"
"			case 2:\n"
"				hairColor += mat.strandBlendScale * strandColor;\n"
"				break;\n"
"			case 3:\n"
"				hairColor += mat.strandBlendScale * (strandColor - 0.5f);\n"
"				break;\n"
"		}\n"
"	}\n"
"\n"
"	return hairColor;\n"
"}\n"
"\n"
"float3 NvHair_SampleHairColor(NvHair_Material mat, float4 texcoords)\n"
"{\n"
"	float3 rootColor = mat.rootColor.rgb;\n"
"	float3 tipColor = mat.tipColor.rgb;\n"
"\n"
"	float ratio = NvHair_GetRootTipRatio(texcoords.z, mat);\n"
"\n"
"	float3 hairColor = lerp(rootColor, tipColor, ratio);\n"
"\n"
"	return hairColor;\n"
"}\n"
"\n"
"float NvHair_ComputeAlpha(\n"
"	NvHair_ConstantBuffer	hairConstantBuffer,\n"
"	NvHair_Material		mat,\n"
"	NvHair_ShaderAttributes attr )\n"
"{\n"
"	float lengthScale = attr.texcoords.z;\n"
"\n"
"	const float epsilon = 0.00000001f;\n"
"	float rootWeight = saturate((lengthScale + epsilon) / (mat.rootAlphaFalloff + epsilon));\n"
"	float rootAlpha = lerp(0.0f, 1.0f, rootWeight);\n"
"\n"
"	float lodAlpha = 1.0f - hairConstantBuffer.lodAlphaFactor;\n"
"\n"
"	float alpha = rootAlpha * lodAlpha;\n"
"\n"
"	return alpha;\n"
"}\n"
"\n"
"float NvHair_SoftDepthCmpGreater(float sampledDepth, float calcDepth)\n"
"{\n"
"	return max(0.0, sampledDepth - calcDepth);\n"
"}\n"
"\n"
"float NvHair_SoftDepthCmpLess(float sampledDepth, float calcDepth)\n"
"{\n"
"	return max(0.0, calcDepth - sampledDepth);\n"
"}\n"
"\n"
"float NvHair_ShadowPcf(\n"
"	float2 texcoord, \n"
"	float calcDepth, \n"
"	SamplerState texSampler, \n"
"	Texture2D shadowTexture, \n"
"	int shadowUseLeftHanded)\n"
"{\n"
"	float shadow = 0;\n"
"	float wsum = 0;\n"
"\n"
"	float w, h;\n"
"	uint numMipLevels;\n"
"	shadowTexture.GetDimensions(0, w, h, numMipLevels);\n"
"\n"
"	float invResolution = 1.0f / float(w);\n"
"\n"
"	[unroll]\n"
"	for (int dx = - 1; dx <= 1; dx ++) {\n"
"		for (int dy = -1; dy <= 1; dy ++) {\n"
"			\n"
"			float w = 1.0f / (1.0f + dx * dx + dy * dy);\n"
"			float2 coords = texcoord + float2(float(dx) * invResolution, float(dy) * invResolution);\n"
"\n"
"			float sampleDepth = SAMPLE_LEVEL(shadowTexture, texSampler, coords, 0).r;  \n"
"			float shadowDepth = NvHair_SoftDepthCmpLess(sampleDepth, calcDepth);\n"
"\n"
"			if (shadowUseLeftHanded == 0)\n"
"				shadowDepth = NvHair_SoftDepthCmpGreater(sampleDepth, calcDepth);\n"
"\n"
"			shadow += w * shadowDepth;\n"
"			wsum += w;\n"
"		}\n"
"	}\n"
"	 \n"
"	float s = shadow / wsum;\n"
"	return s;\n"
"}\n"
"\n"
"float NvHair_ShadowPenetrationDepth(float sampledDepth, float calcDepth, float gain = -1.0f)\n"
"{\n"
"	return max(0.0f, gain * (sampledDepth - calcDepth));\n"
"}\n"
"\n"
"float NvHair_ShadowFilterDepth(Texture2D shadowTexture, SamplerState texSampler, float2 texcoord, float depth, float gain = -1.0f )\n"
"{\n"
"	float filteredDepth = 0;\n"
"	float n = 0;\n"
"\n"
"	[unroll]\n"
"	for (int dx = - 1; dx <= 1; dx += 2) {\n"
"		for (int dy = -1; dy <= 1; dy += 2) {\n"
"\n"
"		    float4 S = shadowTexture.Gather(texSampler, texcoord, int2(dx, dy));\n"
"\n"
"			filteredDepth += NvHair_ShadowPenetrationDepth(S.x, depth, gain);\n"
"			filteredDepth += NvHair_ShadowPenetrationDepth(S.y, depth, gain);\n"
"			filteredDepth += NvHair_ShadowPenetrationDepth(S.z, depth, gain);\n"
"			filteredDepth += NvHair_ShadowPenetrationDepth(S.w, depth, gain);\n"
"\n"
"			n += 4;\n"
"		}\n"
"	}\n"
"	 \n"
"	return filteredDepth / n;\n"
"}\n"
"\n"
"float NvHair_ShadowLitFactor(NvHair_ConstantBuffer constBuf, NvHair_Material mat, float filteredDepth)\n"
"{\n"
"	if (!constBuf.receiveShadows)\n"
"		return 1.0f;\n"
"	return exp( -filteredDepth * mat.shadowSigma);\n"
"}\n"
"\n"
"bool NvHair_VisualizeColor(\n"
"	NvHair_ConstantBuffer	hairConstantBuffer,\n"
"	NvHair_Material			hairMaterial,\n"
"	NvHair_ShaderAttributes attr,\n"
"	inout float3				outColor\n"
"	)\n"
"{\n"
"	switch (hairConstantBuffer.colorizeMode)\n"
"	{\n"
"	case 1: // LOD\n"
"		{\n"
"			float3 zeroColor = float3(0.0, 0.0f, 1.0f);\n"
"			float3 distanceColor	= float3(1.0f, 0.0f, 0.0f);\n"
"			float3 detailColor	= float3(0.0f, 1.0f, 0.0f);\n"
"			float3 alphaColor	= float3(1.0f, 1.0f, 0.0f);\n"
"\n"
"			float distanceFactor = hairConstantBuffer.lodDistanceFactor;\n"
"			float detailFactor = hairConstantBuffer.lodDetailFactor;\n"
"			float alphaFactor = hairConstantBuffer.lodAlphaFactor;\n"
"\n"
"			outColor.rgb = zeroColor; \n"
"\n"
"			if (distanceFactor > 0.0f)\n"
"				outColor.rgb = lerp(zeroColor, distanceColor, distanceFactor);\n"
"\n"
"			if (alphaFactor > 0.0f)\n"
"				outColor.rgb = lerp(zeroColor, alphaColor, alphaFactor);\n"
"\n"
"			if (detailFactor > 0.0f)\n"
"				outColor.rgb = lerp(zeroColor, detailColor, detailFactor);\n"
"\n"
"			break;\n"
"		}\n"
"	case 2: // tangent\n"
"		{\n"
"			outColor.rgb = 0.5f + 0.5f * attr.T.xyz; // colorize hair with its tangnet vector\n"
"			break;\n"
"		}\n"
"	case 3: // normal\n"
"		{\n"
"			outColor.rgb = 0.5f + 0.5f * attr.N.xyz; // colorize hair with its normal vector\n"
"			break;\n"
"		}\n"
"	default:\n"
"		return false;\n"
"	}\n"
"\n"
"	return true; // color computed \n"
"}\n"
"\n"
"\n"
"float4 NvHair_ScreenToClip(float4 input, NvHair_ConstantBuffer hairConstantBuffer)\n"
"{\n"
"	float4 sp;\n"
"\n"
"	// convert to ndc\n"
"	sp.xy = mul( float4(input.x, input.y, 0.0f, 1.0f), hairConstantBuffer.inverseViewport).xy;\n"
"	sp.zw = input.zw;\n"
"\n"
"	// undo perspective division to get clip\n"
"	sp.xyz *= input.w; \n"
"\n"
"	return sp;\n"
"}\n"
"\n"
"float4 NvHair_ScreenToView(float4 pixelPosition, NvHair_ConstantBuffer hairConstantBuffer)\n"
"{\n"
"	float4 ndc = NvHair_ScreenToClip(pixelPosition, hairConstantBuffer);\n"
"	return mul( ndc, hairConstantBuffer.inverseProjection);\n"
"}\n"
"\n"
"float3 NvHair_ScreenToWorld(float4 pixelPosition, NvHair_ConstantBuffer	hairConstantBuffer)\n"
"{\n"
"	float4 wp = mul(float4(pixelPosition.xyz, 1.0f), hairConstantBuffer.inverseViewProjectionViewport);\n"
"	wp.xyz /= wp.w;\n"
"	return wp.xyz;\n"
"}\n"
"\n"
"float4 NvHair_WorldToScreen(float3 worldPos, NvHair_ConstantBuffer	hairConstantBuffer)\n"
"{\n"
"	float4 np = mul(float4(worldPos.xyz, 1.0f), hairConstantBuffer.viewProjection);\n"
"	np.xyz /= np.w;\n"
"\n"
"	float4 vp = mul(float4(np.xyz, 1), hairConstantBuffer.viewport);\n"
"	return float4(vp.xyz, np.w);\n"
"}\n"
"\n"
"float4 NvHair_WorldToScreenPrev(float3 worldPos, NvHair_ConstantBuffer hairConstantBuffer)\n"
"{\n"
"	float4 np = mul(float4(worldPos.xyz, 1.0f), hairConstantBuffer.prevViewProjection);\n"
"	np.xyz /= np.w;\n"
"\n"
"	float4 vp = mul(float4(np.xyz, 1), hairConstantBuffer.prevViewport);\n"
"	return float4(vp.xyz, np.w);\n"
"}\n"
"\n"
"float NvHair_PackFloat2(float2 v)\n"
"{\n"
"	const float base = 2048;\n"
"\n"
"	float basey = floor(base * v.y);\n"
"	float packed = basey + v.x;\n"
"\n"
"	return packed;\n"
"}\n"
"\n"
"float2 NvHair_UnpackFloat2(float packedVal)\n"
"{\n"
"	const float inv_base = 1.0f / 2048.0f;\n"
"\n"
"	float ubase = floor(packedVal);\n"
"	float unpackedy = ubase * inv_base;\n"
"	float unpackedx = packedVal - ubase;\n"
"\n"
"	return float2(unpackedx, unpackedy);\n"
"}\n"
"\n"
"float NvHair_PackSignedFloat(float x)\n"
"{\n"
"	return 0.5f + 0.5f * clamp(x, -1.0, 1.0);\n"
"}\n"
"\n"
"float NvHair_PackSignedFloat2(float2 v)\n"
"{\n"
"	float sx = NvHair_PackSignedFloat(v.x);\n"
"	float sy = NvHair_PackSignedFloat(v.y);\n"
"\n"
"	return NvHair_PackFloat2(float2(sx,sy));\n"
"}\n"
"\n"
"float NvHair_UnpackSignedFloat(float x)\n"
"{\n"
"	return clamp(2.0f * (x - 0.5f), -1.0f, 1.0f);\n"
"}\n"
"\n"
"float2 NvHair_unpackSignedFloat2(float x)\n"
"{\n"
"	float2 unpacked = NvHair_UnpackFloat2(x);\n"
"	float sx = NvHair_UnpackSignedFloat(unpacked.x);\n"
"	float sy = NvHair_UnpackSignedFloat(unpacked.y);\n"
"	return float2(sx, sy);\n"
"}\n"
"\n"
"\n"
"struct NvHair_PixelShaderInput\n"
"{\n"
"	float4 position : SYS_POSITION;\n"
"	float hairtex : HAIR_TEX;\n"
"	NOINTERPOLATION	float compTexcoord : COMP_TEXCOORD;\n"
"\n"
"	NOINTERPOLATION	uint primitiveId : C;\n"
"	NOINTERPOLATION	float coords : COORDS;\n"
"};\n"
"\n"
"struct NvHair_CubemapPixelShaderInput: NvHair_PixelShaderInput\n"
"{\n"
"	uint cubeMapIdx	: SV_RenderTargetArrayIndex;\n"
"};\n"
"\n"
"NvHair_ShaderAttributes NvHair_GetShaderAttributesInternal(NvHair_PixelShaderInput input, NvHair_ConstantBuffer	hairConstantBuffer)\n"
"{\n"
"	NvHair_ShaderAttributes attr;\n"
"\n"
"	attr.P		= NvHair_ScreenToWorld(input.position, hairConstantBuffer);\n"
"\n"
"	attr.texcoords.xy = NvHair_UnpackFloat2(input.compTexcoord.x);\n"
"	attr.texcoords.z = input.hairtex;\n"
"	attr.texcoords.w = 0.5f;\n"
"\n"
"	attr.T = 0;\n"
"	attr.N = 0;\n"
"\n"
"	attr.V = normalize(hairConstantBuffer.camPosition.xyz - attr.P);\n"
"\n"
"	attr.hairID = floor(attr.texcoords.x * 2048 * 2048 + 2048 * attr.texcoords.y);\n"
"\n"
"	return attr;\n"
"}\n"
"\n"
"#define NV_HAIR_INDICES_BUFFER_TYPE	Buffer<float3>\n"
"#define NV_HAIR_TANGENT_BUFFER_TYPE	Buffer<float4>\n"
"#define NV_HAIR_NORMAL_BUFFER_TYPE	Buffer<float4>\n"
"#define NV_HAIR_POSITION_BUFFER_TYPE	Buffer<float4>\n"
"\n"
"#define NV_HAIR_DECLARE_INTERPOLATED_VAR(BUFFER, VAR, INDEX) \\\n"
"	float3 VAR; \\\n"
"	{ \\\n"
"		float3 v0 = BUFFER.Load( INDEX[0] ).xyz; \\\n"
"		float3 v1 = BUFFER.Load( INDEX[1] ).xyz; \\\n"
"		float3 v2 = BUFFER.Load( INDEX[2] ).xyz; \\\n"
"		VAR = coords.x * v0 + coords.y * v1 + (1.0f - coords.x - coords.y) * v2; \\\n"
"	} \n"
"\n"
"#if defined(NV_HAIR_DECLARE_VELOCITY_ATTR)\n"
"#define NV_HAIR_DECLARE_INTERPOLATED_VELOCITY \\\n"
"	NV_HAIR_DECLARE_INTERPOLATED_VAR(NvHair_resourceMasterPositions, P0, vertexIndices0); \\\n"
"	NV_HAIR_DECLARE_INTERPOLATED_VAR(NvHair_resourceMasterPositions, P1, vertexIndices1); \\\n"
"	float3 wP = lerp(P0, P1, hairFrac); \\\n"
"	\\\n"
"	NV_HAIR_DECLARE_INTERPOLATED_VAR(NvHair_resourceMasterPrevPositions, PP0, vertexIndices0); \\\n"
"	NV_HAIR_DECLARE_INTERPOLATED_VAR(NvHair_resourceMasterPrevPositions, PP1, vertexIndices1); \\\n"
"	float3 wPP = lerp(PP0, PP1, hairFrac); \\\n"
"	\\\n"
"	float3 sP = NvHair_WorldToScreen(wP, hairConstantBuffer).xyz;\\\n"
"	float3 sPP = NvHair_WorldToScreenPrev(wPP, hairConstantBuffer).xyz;\\\n"
"	attr.wVel = sP - sPP;\n"
"#else\n"
"#define	NV_HAIR_DECLARE_INTERPOLATED_VELOCITY\n"
"#endif\n"
"/*\n"
"	This macro derived function fills all the attributes needed for hair shading.\n"
"	To get attributes for shaders, use this function defined as\n"
"\n"
"	NvHair_ShaderAttributes NvHair_getShaderAttributes(NvHair_PixelShaderInput input, NvHair_ConstantBuffer	hairConstantBuffer);\n"
"\n"
"	, where input is the pixel shader input and hairConstantBuffer is constant buffer defined for HairWorks.\n"
"	The output (NvHair_ShaderAttributes) contains all the attributes needed for hair shading such as\n"
"		world position (P), \n"
"		tangent (T), \n"
"		surface normal (N), \n"
"		view vector (V), \n"
"		texture coordinates (texcoords)\n"
"		NvHair_getShaderAttributesInternal(INPUT, CBUFFER, NV_HAIR_RESOUCES_VAR)\n"
"\n"
"		float		hairFrac	= hairCoord - float(vertexID0); \\\n"
"\n"
"	*/\n"
"#define NV_HAIR_DECLARE_DEFAULT_SHADER_ATTRIBUTE_FUNC \\\n"
"	NvHair_ShaderAttributes NvHair_GetShaderAttributes(const NvHair_PixelShaderInput input, const NvHair_ConstantBuffer hairConstantBuffer) \\\n"
"	{ \\\n"
"		NvHair_ShaderAttributes attr = NvHair_GetShaderAttributesInternal(input, hairConstantBuffer); \\\n"
"		\\\n"
"		float		hairtex		= attr.texcoords.z; \\\n"
"		const int	numPoints	= hairConstantBuffer.strandPointCount; \\\n"
"		float		hairCoord	= hairtex * float(numPoints-1); \\\n"
"		int			vertexId0	= floor(hairCoord); \\\n"
"		int			vertexId1	= min(vertexId0 + 1, numPoints-1); \\\n"
"		float		hairFrac	= frac(hairCoord); \\\n"
"		\\\n"
"		int3 hairIndices = floor(NvHair_resourceFaceHairIndices.Load(input.primitiveId)); \\\n"
"		int3 rootIndices =  hairIndices * numPoints; \\\n"
"		\\\n"
"		int3	vertexIndices0 = rootIndices + int3(vertexId0, vertexId0, vertexId0); \\\n"
"		int3	vertexIndices1 = rootIndices + int3(vertexId1, vertexId1, vertexId1); \\\n"
"		\\\n"
"		float2	coords = NvHair_UnpackFloat2(input.coords); \\\n"
"		\\\n"
"		NV_HAIR_DECLARE_INTERPOLATED_VAR(NvHair_resourceTangents, T0, vertexIndices0); \\\n"
"		NV_HAIR_DECLARE_INTERPOLATED_VAR(NvHair_resourceTangents, T1, vertexIndices1); \\\n"
"		attr.T = normalize(lerp(T0, T1, hairFrac)); \\\n"
"		\\\n"
"		NV_HAIR_DECLARE_INTERPOLATED_VAR(NvHair_resourceNormals, N0, vertexIndices0); \\\n"
"		NV_HAIR_DECLARE_INTERPOLATED_VAR(NvHair_resourceNormals, N1, vertexIndices1); \\\n"
"		attr.N = normalize(lerp(N0, N1, hairFrac)); \\\n"
"		\\\n"
"		NV_HAIR_DECLARE_INTERPOLATED_VELOCITY;\\\n"
"		\\\n"
"		return attr; \\\n"
"	} \n"
"\n"
"#if defined(NV_HAIR_DECLARE_VELOCITY_ATTR) // use pixel velocity attributes\n"
"\n"
"#define NV_HAIR_DECLARE_SHADER_RESOURCES(SLOT0, SLOT1, SLOT2, SLOT3, SLOT4) \\\n"
"	NV_HAIR_INDICES_BUFFER_TYPE	NvHair_resourceFaceHairIndices	: register(SLOT0); \\\n"
"	NV_HAIR_TANGENT_BUFFER_TYPE	NvHair_resourceTangents			: register(SLOT1); \\\n"
"	NV_HAIR_NORMAL_BUFFER_TYPE	NvHair_resourceNormals			: register(SLOT2); \\\n"
"	NV_HAIR_POSITION_BUFFER_TYPE	NvHair_resourceMasterPositions	: register(SLOT3); \\\n"
"	NV_HAIR_POSITION_BUFFER_TYPE	NvHair_resourceMasterPrevPositions: register(SLOT4); \\\n"
"	NV_HAIR_DECLARE_DEFAULT_SHADER_ATTRIBUTE_FUNC;\n"
"\n"
"#else // don't use pixel velocity attributes\n"
"\n"
"#define NV_HAIR_DECLARE_SHADER_RESOURCES(SLOT0, SLOT1, SLOT2) \\\n"
"	NV_HAIR_INDICES_BUFFER_TYPE	NvHair_resourceFaceHairIndices: register(SLOT0); \\\n"
"	NV_HAIR_TANGENT_BUFFER_TYPE	NvHair_resourceTangents		: register(SLOT1); \\\n"
"	NV_HAIR_NORMAL_BUFFER_TYPE	NvHair_resourceNormals		: register(SLOT2); \\\n"
"	NV_HAIR_DECLARE_DEFAULT_SHADER_ATTRIBUTE_FUNC;\n"
"\n"
"#endif\n"
"\n"
"#endif // NV_HAIR_SHADER_COMMON_H\n"
"\n"
"#ifndef PARAM_CLUMP_SCALE		\n"
"#define PARAM_CLUMP_SCALE		material.clumpScale\n"
"#endif\n"
"\n"
"#ifndef PARAM_CLUMP_NOISE\n"
"#define PARAM_CLUMP_NOISE		material.clumpNoise\n"
"#endif\n"
"\n"
"#ifndef PARAM_CLUMP_ROUNDNESS\n"
"#define PARAM_CLUMP_ROUNDNESS	material.clumpRoundness\n"
"#endif\n"
"\n"
"#ifndef PARAM_WAVE_SCALE\n"
"#define PARAM_WAVE_SCALE		material.waveScale\n"
"#endif\n"
"\n"
"#ifndef PARAM_WAVE_STRAND\n"
"#define PARAM_WAVE_STRAND		material.waveScaleStrand\n"
"#endif\n"
"\n"
"#ifndef PARAM_WAVE_CLUMP\n"
"#define PARAM_WAVE_CLUMP		material.waveScaleClump\n"
"#endif\n"
"\n"
"#ifndef PARAM_WAVE_FREQ\n"
"#define PARAM_WAVE_FREQ			material.waveFreq\n"
"#endif\n"
"\n"
"#ifndef PARAM_WAVE_SCALE_NOISE\n"
"#define PARAM_WAVE_SCALE_NOISE	material.waveScaleNoise\n"
"#endif\n"
"\n"
"#ifndef PARAM_WAVE_FREQ_NOISE\n"
"#define PARAM_WAVE_FREQ_NOISE	material.waveFreqNoise\n"
"#endif\n"
"\n"
"#ifndef PARAM_WAVE_CUTOFF\n"
"#define PARAM_WAVE_CUTOFF		material.waveCutoff\n"
"#endif\n"
"\n"
"#ifndef PARAM_WIDTH\n"
"#define PARAM_WIDTH				material.width\n"
"#endif\n"
"\n"
"#ifndef PARAM_WIDTH_NOISE_SCALE\n"
"#define PARAM_WIDTH_NOISE_SCALE	material.widthNoiseScale\n"
"#endif\n"
"\n"
"#ifndef PARAM_ROOT_WIDTH_SCALE\n"
"#define PARAM_ROOT_WIDTH_SCALE	material.rootWidthScale\n"
"#endif\n"
"\n"
"#ifndef PARAM_TIP_WIDTH_SCALE\n"
"#define PARAM_TIP_WIDTH_SCALE	material.tipWidthScale\n"
"#endif\n"
"\n"
"#ifndef PARAM_LENGTH_SCALE\n"
"#define PARAM_LENGTH_SCALE		material.lengthScale\n"
"#endif\n"
"\n"
"#ifndef PARAM_LENGTH_NOISE\n"
"#define PARAM_LENGTH_NOISE		material.lengthNoise\n"
"#endif\n"
"\n"
"#ifndef OPTIMIZE_RUNTIME\n"
"\n"
"#define	USE_WAVE_SCALE_TEXTURE	1\n"
"#define	USE_WAVE_FREQ_TEXTURE	1\n"
"#define	USE_CLUMP_SCALE_TEXTURE	1\n"
"#define	USE_CLUMP_ROUNDNESS_TEXTURE	1\n"
"#define	USE_WIDTH_TEXTURE		1\n"
"#define	USE_LENGTH_TEXTURE		1\n"
"\n"
"#define USE_PIXEL_DENSITY		1\n"
"#define USE_CULL_SPHERE			1\n"
"#define USE_CLUMPING			1\n"
"#define USE_WAVINESS			1\n"
"#define USE_WAVE_CLUMP			1\n"
"\n"
"#endif\n"
"\n"
"inline float3 NvHair_computeWaveDelta(\n"
"	float	lengthToRoot,\n"
"	float	normalizedNoise,\n"
"	float2	texcoords,\n"
"	float3	hairTangent,\n"
"	float3	hairNormal,\n"
"	in const	NvHair_TessellationMaterial material,\n"
"	float	scale = 1.0f\n"
"	)\n"
"{\n"
"	float3 biTangent1 = normalize(cross(hairTangent, hairNormal));\n"
"	float3 biTangent2 = normalize(cross(hairTangent, biTangent1));\n"
"\n"
"	float waveFreq			= PARAM_WAVE_FREQ;\n"
"	float waveScaleNoise	= PARAM_WAVE_SCALE_NOISE;\n"
"	float waveFreqNoise		= PARAM_WAVE_FREQ_NOISE;\n"
"	float waveCutoff		= PARAM_WAVE_CUTOFF;\n"
"\n"
"	waveScaleNoise = 1.0f + waveScaleNoise * (normalizedNoise - 1.0f);\n"
"	waveFreqNoise = 1.0f + waveFreqNoise* (normalizedNoise - 1.0f);\n"
"	waveFreq = lengthToRoot * TWO_PI * waveFreq * waveFreqNoise;\n"
"\n"
"	float waveCutoffScale = min(1.0f, lengthToRoot / waveCutoff);\n"
"	float waveScale = scale * PARAM_WAVE_SCALE * waveScaleNoise * waveCutoffScale;\n"
"\n"
"#ifndef OPTIMIZE_RUNTIME\n"
"	if (g_buffer.useWaveScaleTexture)\n"
"		waveScale *= NvHair_SampleChannel(g_waveScaleTexture, samLinear, texcoords.xy, g_buffer.waveScaleTextureChan.x);\n"
"#else\n"
"	#if USE_WAVE_SCALE_TEXTURE\n"
"		waveScale *= SAMPLE_WAVE_SCALE(g_waveScaleTexture, samLinear, texcoords, 0);\n"
"	#endif\n"
"#endif\n"
"\n"
"#ifndef OPTIMIZE_RUNTIME\n"
"	if (g_buffer.useWaveFreqTexture)\n"
"		waveFreq *= NvHair_SampleChannel(g_waveFreqTexture, samLinear, texcoords, g_buffer.waveFreqTextureChan.x);\n"
"#else\n"
"	#if USE_WAVE_FREQ_TEXTURE\n"
"	waveFreq *= SAMPLE_WAVE_FREQ(g_waveFreqTexture, samLinear, texcoords, 0);\n"
"	#endif\n"
"#endif\n"
"\n"
"	float3 wave1 = biTangent1 * sin(waveFreq);\n"
"	float3 wave2 = biTangent2 * cos(waveFreq);\n"
"	\n"
"	return waveScale * (wave1 + wave2);\n"
"}\n"
"\n"
"inline float3 gfsdk_pickClump(const float3 coords)\n"
"{\n"
"	if ((coords.x >= coords.y) && (coords.x >= coords.z))\n"
"		return float3(1.0f, 0.0, 0.0);\n"
"	else if ((coords.y >= coords.x) && (coords.y >= coords.z))\n"
"		return float3(0.0f, 1.0, 0.0);\n"
"\n"
"	return float3(0.0f, 0.0, 1.0);\n"
"}\n"
"\n"
"[domain(\"isoline\")]\n"
"DSOut ds_main(\n"
"	OutputPatch<VSOut, 1> inputPatch, \n"
"	HSOut		input, \n"
"	float2		uv : SV_DomainLocation, \n"
"	uint		primitiveId : SV_PrimitiveID)\n"
"{\n"
"	// how many hairs did we render before this master strand\n"
"	uint iHairInsideCurMasterStrand = (int)(uv.y * input.edges[0] + 0.5) + primitiveId * NHAIRS_PER_PATCH;\n"
"	uint vertexId					= (int)(uv.x * input.edges[1] + 0.5);\n"
"	float lengthToRoot				= uv.x;\n"
"	uint instanceId					= iHairInsideCurMasterStrand + floor(g_buffer.densityPass * NHAIRS_PER_PATCH);\n"
"\n"
"	// hair cv id\n"
"	int3 rootIndices	= floor(input.rootIndices);\n"
"	int3 vertexIndices  = rootIndices + int3(vertexId, vertexId, vertexId);\n"
"\n"
"	// barycentric coordinates\n"
"	float3 coords;\n"
"	coords.xy = g_strandCoordinatesLut.Load(instanceId & NUM_INTERPOLATED_ATTRIBUTES_MINUS_ONE);\n"
"	coords.z = (1 - coords.x - coords.y);\n"
"\n"
"	// texcoords ----------------------------------------------------------------------------------\n"
"	float2 texcoords = \n"
"		coords.x * input.texcoords[0].xy + \n"
"		coords.y * input.texcoords[1].xy + \n"
"		coords.z * input.texcoords[2].xy;\n"
"\n"
"	NvHair_TessellationMaterial material = g_buffer.defaultMaterial;\n"
"\n"
"	DSOut	output = (DSOut)0;\n"
"\n"
"	// get common noise variables\n"
"	float normalizedNoise = g_noiseLut.Load(instanceId & NUM_INTERPOLATED_ATTRIBUTES_MINUS_ONE);\n"
"	float signedNoise = 2.0f * (normalizedNoise - 0.5f);\n"
"\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	// early out on per pixel density\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"#ifndef OPTIMIZE_RUNTIME\n"
"	if (g_buffer.usePixelDensity && g_buffer.useDensityTexture)\n"
"	{\n"
"		float densitySample = normalizedNoise + 0.005; // add small bias to avoid dark spot having hair (1/200)\n"
"		float density = NvHair_SampleChannel(g_densityTexture, samLinear, texcoords, g_buffer.densityTextureChan.x);\n"
"\n"
"		if (densitySample > density)\n"
"			return output;\n"
"	}\n"
"#else // optimized version\n"
"\n"
"#if USE_PIXEL_DENSITY && USE_DENSITY_TEXTURE\n"
"	float densitySample = normalizedNoise + 0.005; // add small bias to avoid dark spot having hair (1/200)\n"
"	float density = SAMPLE_DENSITY(g_densityTexture, samLinear, texcoords, 0);\n"
"\n"
"	if (densitySample > density)\n"
"		return output;\n"
"#endif\n"
"#endif\n"
"\n"
"	///////////////////////////////////////////////////////////////////////////////\n"
"	// interpolate position, normal, tangents\n"
"	///////////////////////////////////////////////////////////////////////////////\n"
"	\n"
"	float4 p0 = g_tessellatedMasterStrand.Load(vertexIndices[0]);\n"
"	float4 p1 = g_tessellatedMasterStrand.Load(vertexIndices[1]);\n"
"	float4 p2 = g_tessellatedMasterStrand.Load(vertexIndices[2]);\n"
"	\n"
"	float4 positionAndLength = NvHair_InterpolateBary(p0, p1, p2, coords);\n"
"	float3 position = positionAndLength.xyz;\n"
"	float3 barycentricPosition = position;\n"
"\n"
"	float3 hairTangent = 0;\n"
"	float3 t0 = 0, t1 = 0, t2 = 0;\n"
"	{\n"
"		t0 = g_tessellatedTangents.Load( vertexIndices[0] ).xyz;\n"
"		t1 = g_tessellatedTangents.Load( vertexIndices[1] ).xyz;\n"
"		t2 = g_tessellatedTangents.Load( vertexIndices[2] ).xyz;\n"
"\n"
"		hairTangent = NvHair_InterpolateBary(t0, t1, t2, coords);\n"
"	}\n"
"\n"
"	float3 hairNormal = 0;\n"
"	{\n"
"		float3 n0 = g_tessellatedNormals.Load( vertexIndices[0] ).xyz;\n"
"		float3 n1 = g_tessellatedNormals.Load( vertexIndices[1] ).xyz;\n"
"		float3 n2 = g_tessellatedNormals.Load( vertexIndices[2] ).xyz; \n"
"\n"
"		hairNormal = NvHair_InterpolateBary(n0, n1, n2, coords);\n"
"	}\n"
"\n"
"	///////////////////////////////////////////////////////////////////////////////\n"
"	// strand waviness\n"
"	///////////////////////////////////////////////////////////////////////////////\n"
"#if USE_WAVINESS\n"
"	float waveScale		= PARAM_WAVE_SCALE;\n"
"	position.xyz += NvHair_computeWaveDelta(lengthToRoot, normalizedNoise, texcoords, hairTangent, hairNormal, material, PARAM_WAVE_STRAND);\n"
"#endif\n"
"\n"
"	////////////////////////////////////////////////////////////////////////////////\n"
"	// Clumping\n"
"	///////////////////////////////////////////////////////////////////////////////\n"
"#if USE_CLUMPING\n"
"\n"
"	float clumpScale		= PARAM_CLUMP_SCALE;\n"
"	float clumpNoise		= PARAM_CLUMP_NOISE;\n"
"	float clumpRoundness	= PARAM_CLUMP_ROUNDNESS;\n"
"	float3 clumpDelta		= float3(0,0,0);\n"
"\n"
"	if (clumpScale > 0)\n"
"	{\n"
"		float3	clumpedPosition = p2.xyz;\n"
"		float3	clumpedHairTangent = t2.xyz;\n"
"		uint	clumpedVertexId = rootIndices[2]; // hash value that need to be same for vertices of same hair.\n"
"		\n"
"		{\n"
"			if ((coords.x >= coords.y) && (coords.x >= coords.z)) // pick first vertex\n"
"			{\n"
"				clumpedPosition = p0.xyz;\n"
"				clumpedHairTangent = t0.xyz;\n"
"				clumpedVertexId = rootIndices[0];\n"
"			}\n"
"			else if ((coords.y >= coords.x) && (coords.y >= coords.z))\n"
"			{\n"
"				clumpedPosition = p1.xyz;\n"
"				clumpedHairTangent = t1.xyz;\n"
"				clumpedVertexId = rootIndices[1];\n"
"			}\n"
"		}\n"
"\n"
"#if USE_WAVE_CLUMP	\n"
"#ifndef OPTIMIZE_RUNTIME\n"
"		if (PARAM_WAVE_CLUMP > 0.0f)\n"
"#endif\n"
"		{\n"
"			float	clumpNoise = g_noiseLut.Load(clumpedVertexId & NUM_INTERPOLATED_ATTRIBUTES_MINUS_ONE);\n"
"			clumpedPosition += NvHair_computeWaveDelta(\n"
"				lengthToRoot, clumpNoise, texcoords, clumpedHairTangent, hairNormal, material, PARAM_WAVE_CLUMP);\n"
"		}\n"
"#endif\n"
"\n"
"#ifndef OPTIMIZE_RUNTIME\n"
"		if (g_buffer.useClumpScaleTexture)\n"
"			clumpScale *= NvHair_SampleChannel(g_clumpScaleTexture, samLinear, texcoords, g_buffer.clumpScaleTextureChan.x);\n"
"#else\n"
"		#if USE_CLUMP_SCALE_TEXTURE\n"
"		clumpScale *= SAMPLE_CLUMP_SCALE(g_clumpScaleTexture, samLinear, texcoords, 0);\n"
"		#endif\n"
"#endif\n"
"\n"
"#ifndef OPTIMIZE_RUNTIME\n"
"		if (g_buffer.useClumpRoundnessTexture)\n"
"			clumpRoundness *= NvHair_SampleChannel(g_clumpRoundnessTexture, samLinear, texcoords, g_buffer.clumpRoundnessTextureChan.x);\n"
"#else\n"
"		#if USE_CLUMP_ROUNDNESS_TEXTURE\n"
"			clumpRoundness *= SAMPLE_CLUMP_ROUNDNESS(g_clumpRoundnessTexture, samLinear, texcoords, 0);\n"
"		#endif\n"
"#endif\n"
"\n"
"		float clumpness = pow(lengthToRoot, clumpRoundness);\n"
"		clumpness *= lerp(1.0f, normalizedNoise, clumpNoise);\n"
"		clumpness *= clumpScale;\n"
"\n"
"		// displace delta\n"
"		clumpDelta = clumpness * (clumpedPosition - barycentricPosition);\n"
"	}\n"
"\n"
"	position.xyz += clumpDelta;\n"
"#endif\n"
"\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	// Width control\n"
"	///////////////////////////////////////////////////////////////////////////////\n"
"	float width = PARAM_WIDTH;\n"
"\n"
"#ifndef OPTIMIZE_RUNTIME\n"
"	if (g_buffer.useWidthTexture)\n"
"		width *= NvHair_SampleChannel(g_widthTexture, samLinear, texcoords, g_buffer.widthTextureChan.x);\n"
"#else\n"
"\n"
"#if USE_WIDTH_TEXTURE\n"
"	width *= SAMPLE_WIDTH(g_widthTexture, samLinear, texcoords, 0);\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"	float rootWidthScale	= PARAM_ROOT_WIDTH_SCALE;\n"
"	float tipWidthScale		= PARAM_TIP_WIDTH_SCALE;\n"
"\n"
"	// taper hair by two width scale\n"
"	float widthScale = clamp(lerp(rootWidthScale, tipWidthScale, lengthToRoot), 0, max(rootWidthScale, tipWidthScale));\n"
"	width *= widthScale * (1.0f + PARAM_WIDTH_NOISE_SCALE * signedNoise);\n"
"\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	// Length variation\n"
"	///////////////////////////////////////////////////////////////////////////////\n"
"	float length = PARAM_LENGTH_SCALE * (lerp(1.0f, 0.2f + 0.8f * normalizedNoise, PARAM_LENGTH_NOISE));\n"
"\n"
"#ifndef OPTIMIZE_RUNTIME\n"
"	if (g_buffer.useLengthTexture)\n"
"		length *= NvHair_SampleChannel(g_lengthTexture, samLinear, texcoords, g_buffer.lengthTextureChan);\n"
"#else\n"
"\n"
"#if USE_LENGTH_TEXTURE\n"
"\n"
"		length *= SAMPLE_LENGTH(g_lengthTexture, samLinear, texcoords, 0);\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"	if (lengthToRoot > length) \n"
"		width = 0.0f;\n"
"\n"
"#if USE_CULL_SPHERE\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	// cull sphere for dismemberment\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	if (g_buffer.useCullSphere)\n"
"	{\n"
"		float3 rp0 = g_restMasterStrand.Load( rootIndices[0] ).xyz;\n"
"		float3 rp1 = g_restMasterStrand.Load( rootIndices[1] ).xyz;\n"
"		float3 rp2 = g_restMasterStrand.Load( rootIndices[2] ).xyz;\n"
"\n"
"		float3 rootBary = NvHair_InterpolateBary(rp0, rp1, rp2, coords);\n"
"\n"
"		float3 transformedRoot = mul(float4(rootBary, 1), g_buffer.cullSphereInvTransform).xyz;\n"
"\n"
"		if (dot(transformedRoot, transformedRoot) < 1.0) // inside culling sphere\n"
"			width = 0.0f; // discard by length in GS\n"
"	}\n"
"#endif\n"
"\n"
"	////////////////////////////////////////////////////////////\n"
"	// normalize interpolated vectors\n"
"	////////////////////////////////////////////////////////////\n"
"	hairTangent		= normalize(hairTangent);\n"
"	hairNormal		= normalize(hairNormal);\n"
"\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	// DS output\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	output.position		= position.xyz;\n"
"	output.texcoords	= texcoords;\n"
"	output.width		= width;\n"
"	output.tex			= lengthToRoot;\n"
"	output.tangent		= hairTangent;\n"
"	output.normal		= hairNormal;\n"
"\n"
"	output.primitiveId = input.primitiveId;\n"
"	output.coords = coords.xy;\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"\n"
;