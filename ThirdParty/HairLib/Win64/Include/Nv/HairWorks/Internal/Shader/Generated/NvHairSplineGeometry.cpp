///////////////////////////////////////////////////////////////////////////////////////////////
// This file was generated by <HairWorks>/external/shader_preprocess/bin/shader_preprocess.exe 
// Source file:			NvHairSplineGeometry.hlsl
// Include path:		..\..\..\Nv\HairWorks\Internal\Shader\Geometry\
// Output file:			..\..\..\Nv\HairWorks\Internal\Shader\Generated\NvHairSplineGeometry.cpp
// Generated at 2017-04-16.23:28:10
///////////////////////////////////////////////////////////////////////////////////////////////
const char* shaderVar =
"#define OPTIMIZE_RUNTIME\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_SPLINE_H\n"
"#define NV_HAIR_SPLINE_H\n"
"\n"
"#ifdef _CPP\n"
"#	error \"Can only be included in HLSL code\"\n"
"#endif\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"#define NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"\n"
"#define NUM_INTERPOLATED_ATTRIBUTES_MINUS_ONE 1023\n"
"#define NUM_INTERPOLATED_ATTRIBUTES 1024\n"
"#define LUT_SIZE_MINUS_ONE 1023\n"
"\n"
"#define NHAIRS_PER_PATCH 64\n"
"#define NSEGMENTS_PER_PATCH 256 \n"
"\n"
"#define TWO_PI 3.141592 * 2.0f\n"
"\n"
"#ifndef FLT_EPSILON\n"
"#define FLT_EPSILON	0.0000001f\n"
"#endif\n"
"\n"
"#ifdef _CPP // C++ code\n"
"\n"
"#define float4			gfsdk_float4\n"
"#define float3			gfsdk_float3\n"
"#define float2			gfsdk_float2\n"
"#define float4x4		gfsdk_float4x4\n"
"#define matrix4			gfsdk_float4x4\n"
"#define DualQuaternion	gfsdk_dualquaternion\n"
"\n"
"typedef int				int2[2];\n"
"typedef int				int4[4];\n"
"\n"
"#define lerp			gfsdk_lerp\n"
"\n"
"#else // shader\n"
"\n"
"struct DualQuaternion\n"
"{\n"
"	float4 q0;\n"
"	float4 q1;\n"
"};\n"
"\n"
"#define matrix4			row_major float4x4\n"
"#define MATERIAL_CHANNELS	float2\n"
"\n"
"inline float NvHair_LerpChannel(float2 channel, float s)\n"
"{\n"
"	return channel.x;\n"
"}\n"
"\n"
"#define SAMPLE_RED(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).r;\n"
"#define SAMPLE_GREEN(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).g;\n"
"#define SAMPLE_BLUE(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).b;\n"
"#define SAMPLE_ALPHA(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).a;\n"
"\n"
"#define NV_HAIR_SAMPLE_CHANNEL(TEX, SAMPLER, TEXCOORD, MIPLEVEL, CHANNEL, SAMPLE) \\\n"
"	if (CHANNEL == 0) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).r; \\\n"
"	else if (CHANNEL == 1) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).g; \\\n"
"	else if (CHANNEL == 2) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).b; \\\n"
"	else if (CHANNEL == 3) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).a;\n"
"\n"
"inline float NvHair_SampleChannel( Texture2D tex, SamplerState texSampler, float2 texcoords, int channel, float weight = 1.0f)\n"
"{\n"
"	float sample = 1.0f;\n"
"	NV_HAIR_SAMPLE_CHANNEL(tex, texSampler, texcoords, 0, channel, sample);\n"
"	return sample;\n"
"}\n"
"\n"
"#endif // _CPP \n"
"\n"
"#endif  // NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_INTERNAL_SHADER_TYPES_H\n"
"#define NV_HAIR_INTERNAL_SHADER_TYPES_H\n"
"\n"
"/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n"
"* NVIDIA CORPORATION and its licensors retain all intellectual property\n"
"* and proprietary rights in and to this software, related documentation\n"
"* and any modifications thereto.  Any use, reproduction, disclosure or\n"
"* distribution of this software and related documentation without an express\n"
"* license agreement from NVIDIA CORPORATION is strictly prohibited. */\n"
"\n"
"#ifndef NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"#define NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"\n"
"#define NUM_INTERPOLATED_ATTRIBUTES_MINUS_ONE 1023\n"
"#define NUM_INTERPOLATED_ATTRIBUTES 1024\n"
"#define LUT_SIZE_MINUS_ONE 1023\n"
"\n"
"#define NHAIRS_PER_PATCH 64\n"
"#define NSEGMENTS_PER_PATCH 256 \n"
"\n"
"#define TWO_PI 3.141592 * 2.0f\n"
"\n"
"#ifndef FLT_EPSILON\n"
"#define FLT_EPSILON	0.0000001f\n"
"#endif\n"
"\n"
"#ifdef _CPP // C++ code\n"
"\n"
"#define float4			gfsdk_float4\n"
"#define float3			gfsdk_float3\n"
"#define float2			gfsdk_float2\n"
"#define float4x4		gfsdk_float4x4\n"
"#define matrix4			gfsdk_float4x4\n"
"#define DualQuaternion	gfsdk_dualquaternion\n"
"\n"
"typedef int				int2[2];\n"
"typedef int				int4[4];\n"
"\n"
"#define lerp			gfsdk_lerp\n"
"\n"
"#else // shader\n"
"\n"
"struct DualQuaternion\n"
"{\n"
"	float4 q0;\n"
"	float4 q1;\n"
"};\n"
"\n"
"#define matrix4			row_major float4x4\n"
"#define MATERIAL_CHANNELS	float2\n"
"\n"
"inline float NvHair_LerpChannel(float2 channel, float s)\n"
"{\n"
"	return channel.x;\n"
"}\n"
"\n"
"#define SAMPLE_RED(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).r;\n"
"#define SAMPLE_GREEN(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).g;\n"
"#define SAMPLE_BLUE(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).b;\n"
"#define SAMPLE_ALPHA(TEX, SAMPLER, TEXCOORD, MIPLEVEL) TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).a;\n"
"\n"
"#define NV_HAIR_SAMPLE_CHANNEL(TEX, SAMPLER, TEXCOORD, MIPLEVEL, CHANNEL, SAMPLE) \\\n"
"	if (CHANNEL == 0) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).r; \\\n"
"	else if (CHANNEL == 1) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).g; \\\n"
"	else if (CHANNEL == 2) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).b; \\\n"
"	else if (CHANNEL == 3) \\\n"
"		SAMPLE = TEX.SampleLevel(SAMPLER, TEXCOORD, MIPLEVEL).a;\n"
"\n"
"inline float NvHair_SampleChannel( Texture2D tex, SamplerState texSampler, float2 texcoords, int channel, float weight = 1.0f)\n"
"{\n"
"	float sample = 1.0f;\n"
"	NV_HAIR_SAMPLE_CHANNEL(tex, texSampler, texcoords, 0, channel, sample);\n"
"	return sample;\n"
"}\n"
"\n"
"#endif // _CPP \n"
"\n"
"#endif  // NV_HAIR_INTERNAL_SHADER_COMMON_H\n"
"\n"
"\n"
"#define NV_HAIR_MAX_BONE_MATRICES 256\n"
"\n"
"#define	NV_HAIR_MAX_COLLISION_SPHERES 128\n"
"#define NV_HAIR_MAX_COLLISION_CAPSULES 128\n"
"\n"
"#define	NV_HAIR_MAX_PINS 32\n"
"\n"
"#define NV_HAIR_BLOCK_SIZE_SIMULATE 64\n"
"#define NV_HAIR_BLOCK_SIZE_PIN_COM 1024\n"
"\n"
"\n"
"struct NvHair_SimulationMaterial\n"
"{\n"
"	float		stiffness;\n"
"	float		damping;\n"
"	float		stiffnessStrength;\n"
"	float		stiffnessDamping;\n"
"\n"
"	float		rootStiffness;\n"
"	float		tipStiffness;\n"
"	float		bendStiffness;\n"
"	float		interactionStiffness;\n"
"\n"
"	float		pinStiffness;\n"
"	float		inertiaScale;\n"
"	float		backStopRadius;\n"
"	float		friction;\n"
"\n"
"	float		hairNormalWeight;\n"
"	float		massScale;\n"
"	float		_reserved2_;\n"
"	float		_reserved3_;\n"
"\n"
"	float4		stiffnessCurve;\n"
"	float4		stiffnessStrengthCurve;\n"
"	float4		stiffnessDampingCurve;\n"
"	float4		bendStiffnessCurve;\n"
"	float4		interactionStiffnessCurve;\n"
"};\n"
"\n"
"#define NV_HAIR_LERP_SIMULATION_PARAM(BUFFER, PARAM) \\\n"
"	PARAM	= lerp(BUFFER.defaultMaterial.PARAM, BUFFER.targetMaterial.PARAM, BUFFER.materialWeight);\n"
"\n"
"struct NvHair_SimulateConstantBuffer\n"
"{\n"
"	matrix4 boneMatrices[NV_HAIR_MAX_BONE_MATRICES];\n"
"	matrix4 skinMatrices[NV_HAIR_MAX_BONE_MATRICES];\n"
"	DualQuaternion skinDqs[NV_HAIR_MAX_BONE_MATRICES];\n"
"\n"
"	matrix4 modelToWorld;\n"
"\n"
"	float4 modelCenter;\n"
"	float4 modelCenterRest;\n"
"\n"
"	float4 gravity;\n"
"\n"
"	float3 wind;\n"
"	float windNoise;\n"
"\n"
"	int numBones;\n"
"	int numTotalCvs;\n"
"	int numCollisionSpheres;\n"
"	int numCollisionCapsules;\n"
"\n"
"	int numPinConstraints;\n"
"	int useCollision;\n"
"	int useDynamicPin;\n"
"	int useDualQuaterinon;\n"
"\n"
"	int numTubeVertices; // NUTT\n"
"	int numStrands; // NUTT\n"
"	int numParsPerStrand; // NUTT\n"
"	int numSubSegments; // NUTT\n"
"\n"
"	float kInterpolation; // NUTT\n"
"	float simulationInterp;					///< Used on prepare interp to calculate the simulation interpolation\n"
"	int tmp2;\n"
"	int tmp3;\n"
"\n"
"	int numConstraintIterations;\n"
"	float timeStep;\n"
"	int simulate;\n"
"	int lockInertia;\n"
"\n"
"	float maxHairLength;\n"
"	int stiffnessChannel;\n"
"	int rootStiffnessChannel;\n"
"	float _reserved3_;\n"
"\n"
"	int useStiffnessTexture;\n"
"	int useRootStiffnessTexture;\n"
"	int useWeightTexture;\n"
"	float materialWeight;\n"
"\n"
"	NvHair_SimulationMaterial defaultMaterial;\n"
"	NvHair_SimulationMaterial targetMaterial;\n"
"\n"
"	float4 collisionSpheres[NV_HAIR_MAX_COLLISION_SPHERES];\n"
"	float4 collisionCapsuleIndex[NV_HAIR_MAX_COLLISION_CAPSULES];\n"
"};\n"
"\n"
"\n"
"struct NvHair_TessellationMaterial // packed to 2 channel for faster sampling/interpolation\n"
"{\n"
"	float		width;\n"
"	float		widthNoiseScale;\n"
"	float		rootWidthScale;\n"
"	float		tipWidthScale;\n"
"\n"
"	float		density;\n"
"	float		clumpScale;\n"
"	float		clumpNoise;\n"
"	float		clumpRoundness;\n"
"\n"
"	float		lengthNoise;\n"
"	float		lengthScale;\n"
"	float		__reserved1__;\n"
"	float		__reserved2__;\n"
"\n"
"	float		waveScale;\n"
"	float		waveScaleNoise;\n"
"	float		waveScaleStrand;\n"
"	float		waveScaleClump;\n"
"\n"
"	float		waveFreq;\n"
"	float		waveFreqNoise;\n"
"	float		waveCutoff;\n"
"	float		__reserved3__;\n"
"};\n"
"\n"
"struct NvHair_TessellationConstantBuffer\n"
"{\n"
"	// transforms\n"
"	matrix4	viewProjection;\n"
"	matrix4	viewMatrix;\n"
"	matrix4	inverseViewMatrix;\n"
"	matrix4	modelToWorld;\n"
"	matrix4	cullSphereInvTransform;\n"
"	float4 camPosition;\n"
"\n"
"	// tessellation materials\n"
"	NvHair_TessellationMaterial defaultMaterial;\n"
"	NvHair_TessellationMaterial targetMaterial;\n"
"\n"
"	// texture bit\n"
"	int useDensityTexture;\n"
"	int	useWidthTexture;\n"
"	int	useClumpScaleTexture;\n"
"	int useClumpRoundnessTexture;\n"
"\n"
"	int useClumpNoiseTexture;\n"
"	int useWaveScaleTexture;\n"
"	int useWaveFreqTexture;\n"
"	int useLengthTexture;\n"
"\n"
"	// material control\n"
"	float materialWeight;\n"
"	int useWeightTexture;\n"
"	unsigned int strandPointCount;\n"
"	float __reserved1__;\n"
"\n"
"	// shader settings\n"
"	unsigned int shaderMask;\n"
"	int leftHanded;\n"
"	int vertexClumping;\n"
"	float __reserved2_;\n"
"\n"
"	// density option\n"
"	int usePixelDensity;\n"
"	float densityPass;\n"
"	float __reserved3__;\n"
"	float __reserved2__;\n"
"\n"
"	// culling\n"
"	int useViewfrustrumCulling;\n"
"	float useBackfaceCulling;\n"
"	float backfaceCullingThreshold;\n"
"	int useCullSphere;\n"
"\n"
"	// channels\n"
"	int2 densityTextureChan;\n"
"	int2 widthTextureChan;\n"
"\n"
"	int2 clumpScaleTextureChan;\n"
"	int2 clumpRoundnessTextureChan;\n"
"\n"
"	int2 waveScaleTextureChan;\n"
"	int2 waveFreqTextureChan;\n"
"\n"
"	int2 lengthTextureChan;\n"
"	int2 weightTextureChan;\n"
"\n"
"	// Cubemap rendering info\n"
"	int4 cubeMapActive;\n"
"	matrix4	cubeMapViewProjMatrix[6];\n"
"	matrix4	cubeMapInvViewMatrix[6];\n"
"	int4 cubeMapVisible[6];\n"
"};\n"
"\n"
"\n"
"struct NvHair_Pin\n"
"{\n"
"	matrix4 invHairPoseMatrix;\n"
"	matrix4 currentHairMatrix;\n"
"\n"
"	matrix4 invPinPoseMatrix; // = inverse pose\n"
"	matrix4 currentPinMatrix;\n"
"	matrix4 shapeMatrix;\n"
"\n"
"	float radius;\n"
"	float3 localPos;\n"
"\n"
"	int boneIndex;\n"
"	float3 restComShift;\n"
"\n"
"	int rootBoneIndex;\n"
"	float rootBoneDis;\n"
"	int stiffPin;\n"
"	int doLra;\n"
"\n"
"	float3 restTangent;\n"
"	int useDynamicPin;\n"
"\n"
"	float stiffness;\n"
"	float influenceFallOff;\n"
"	int selected;\n"
"	float __align__;\n"
"\n"
"	float4 influenceFallOffCurve;\n"
"};\n"
"\n"
"#define NV_HAIR_SCRATCH_SIZE_PER_PIN 128 // = 128 * 1024 = 130K simulated CVs\n"
"struct NvHair_PinScratchData\n"
"{\n"
"	float4 com;\n"
"	float4 tangent;\n"
"};\n"
"\n"
"\n"
"struct NvHair_SplineConstantBuffer\n"
"{\n"
"	matrix4 modelToWorld;\n"
"\n"
"	unsigned int numVertsPerSegments;\n"
"	unsigned int numMasterSegments;\n"
"	unsigned int numTessellatedPoints;\n"
"	unsigned int strandPointCounts;\n"
"\n"
"	float simulationInterp;\n"
"	float __unused__[3];\n"
"};\n"
"\n"
"\n"
"struct NvHair_VisualizeConstantBuffer\n"
"{\n"
"	matrix4 viewProjection;\n"
"	matrix4 modelToWorld;\n"
"\n"
"	float4 color;\n"
"\n"
"	int hairMin;\n"
"	int hairMax;\n"
"	int hairSkip;\n"
"	int hairDummy;\n"
"\n"
"	float hairWidth;\n"
"	float aspect;\n"
"	float scale;\n"
"	int pinId;\n"
"};\n"
"\n"
"\n"
"struct NvHair_StatsPerFrameConstantBuffer\n"
"{\n"
"	int		numFaces;\n"
"	int		usePixelDensity;\n"
"	float	density;\n"
"	int		_dummy;\n"
"};\n"
"\n"
"\n"
"#endif  // NV_HAIR_INTERNAL_SHADER_TYPES_H\n"
"\n"
"\n"
"struct VSOut\n"
"{\n"
"    uint	vertexId : vertexID;\n"
"};\n"
"\n"
"#endif // NV_HAIR_SPLINE_H"
"\n"
"cbuffer cbPerFrame : register( b0 )\n"
"{\n"
"	NvHair_SplineConstantBuffer g_buffer;\n"
"}\n"
"\n"
"StructuredBuffer<float4>	g_masterStrandSb		: register(t0);\n"
"StructuredBuffer<float4>	g_masterStrandPrevSb	: register(t1);\n"
"StructuredBuffer<float4>	g_deltaParticlePos		: register(t2); // Delta particle pos\n"
"StructuredBuffer<float4>	g_masterStrandNormals	: register(t3);\n"
"\n"
"struct GSOut\n"
"{\n"
"    float4 position : POSITION;\n"
"    float4 tangent	: TANGENT;\n"
"	float4 normal	: NORMAL;\n"
"};\n"
"\n"
"[MaxVertexCount(1)]\n"
"void gs_main(point VSOut input[1], inout PointStream<GSOut> inStream )\n"
"{ \n"
"    GSOut output = (GSOut)0;\n"
"\n"
"	// hash input vertex id into various indices needed to compute spline factors   \n"
"	int vertexId				= input[0].vertexId;\n"
"	int numVertsPerSegments		= g_buffer.numVertsPerSegments;\n"
"	int	numMasterSegments		= g_buffer.numMasterSegments;\n"
"	int	numMasterCvs			= numMasterSegments + 1;\n"
"	int strandPointCounts		= g_buffer.strandPointCounts;\n"
"\n"
"	int hairId					= vertexId / strandPointCounts;\n"
"	int strandVertexId			= vertexId - hairId * strandPointCounts;\n"
"\n"
"	int segmentId				= strandVertexId / numVertsPerSegments;\n"
"	bool lastVertex				= (strandVertexId == (strandPointCounts - 1));\n"
"\n"
"	if (lastVertex)\n"
"		segmentId = numMasterSegments - 1;\n"
"\n"
"	bool firstSegment			= segmentId == 0;\n"
"	bool lastSegment			= segmentId >= (numMasterSegments - 1);\n"
"	\n"
"	int segmentVertexIndex		= strandVertexId - segmentId * numVertsPerSegments;\n"
"	float u						= segmentVertexIndex / float(numVertsPerSegments);\n"
"	int controlVertexBase		= hairId * numMasterCvs;\n"
"\n"
"    // Catmull-Rom basis\n"
"    float4x4 basisMatrix = float4x4\n"
"    (\n"
"        -0.5,	1.5,   -1.5,	0.5,\n"
"		 1.0,  -2.5,	2.0,   -0.5,\n"
"		-0.5,	0.0,	0.5,	0.0,\n"
"		 0.0,	1.0,	0.0,	0.0\n"
"    );\n"
"\n"
"    float4 basis = mul(float4(u * u * u, u * u, u, 1), basisMatrix);\n"
"\n"
"	// control vertices and normals\n"
"	int4 cvId;\n"
"\n"
"	cvId[0] = controlVertexBase + (firstSegment ? segmentId : segmentId - 1);\n"
"	cvId[1] = controlVertexBase + segmentId;\n"
"	cvId[2] = controlVertexBase + segmentId + 1;\n"
"	cvId[3] = controlVertexBase + (lastSegment ? (segmentId + 1) : (segmentId + 2));\n"
"\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	// position\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"\n"
"	float4 position = float4(0, 0, 0, 0);\n"
"	float4x4 controlVertices;\n"
"\n"
"	float interp = g_buffer.simulationInterp;\n"
"	if (interp >= 1.0f)\n"
"	{\n"
"		controlVertices[0] = g_masterStrandSb[cvId[0]];\n"
"		controlVertices[1] = g_masterStrandSb[cvId[1]];\n"
"		controlVertices[2] = g_masterStrandSb[cvId[2]];\n"
"		controlVertices[3] = g_masterStrandSb[cvId[3]];\n"
"	}\n"
"	else\n"
"	{\n"
"		// Add the delta, to the position (can just set because we know it's zero at this point)\n"
"		position = g_deltaParticlePos[controlVertexBase];\n"
"\n"
"		// Lerp the control vertices between old and new\n"
"		controlVertices[0] = lerp(g_masterStrandPrevSb[cvId[0]], g_masterStrandSb[cvId[0]], interp);\n"
"		controlVertices[1] = lerp(g_masterStrandPrevSb[cvId[1]], g_masterStrandSb[cvId[1]], interp);\n"
"		controlVertices[2] = lerp(g_masterStrandPrevSb[cvId[2]], g_masterStrandSb[cvId[2]], interp);\n"
"		controlVertices[3] = lerp(g_masterStrandPrevSb[cvId[3]], g_masterStrandSb[cvId[3]], interp);\n"
"	}\n"
"\n"
"	[unroll] for (int c = 0; c < 4; ++c)\n"
"		position += basis[c] * controlVertices[c];\n"
"\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	// normal\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"\n"
"	float4x4 controlNormals;\n"
"\n"
"	controlNormals[0] = g_masterStrandNormals[cvId[0]];\n"
"	controlNormals[1] = g_masterStrandNormals[cvId[1]];\n"
"	controlNormals[2] = g_masterStrandNormals[cvId[2]];\n"
"	controlNormals[3] = g_masterStrandNormals[cvId[3]];\n"
"\n"
"	float4 normal = float4(0,0,0,0);\n"
"    [unroll] for (int n = 0; n < 4; ++n) \n"
"        normal += basis[n] * controlNormals[n];\n"
"\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"    // tangents\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"    float3x3 basisMatrixQuadratic = float3x3\n"
"    (\n"
"        0.5, -1.0, 0.5,\n"
"       -1.0,  1.0, 0.0,\n"
"        0.5,  0.5, 0.0\n"
"    );    \n"
"    \n"
"    float3 basisTangents  = mul(float3(u * u, u, 1), basisMatrixQuadratic);\n"
"    \n"
"    const float3 controlTangents[3] = \n"
"    {\n"
"        float3(controlVertices[1].xyz - controlVertices[0].xyz),\n"
"        float3(controlVertices[2].xyz - controlVertices[1].xyz),\n"
"        float3(controlVertices[3].xyz - controlVertices[2].xyz),        \n"
"    };\n"
"    \n"
"	float4 tangent = float4(0,0,0,0);\n"
"    [unroll] for (c = 0; c < 3; ++c) \n"
"        tangent.xyz += basisTangents[c] * controlTangents[c];\n"
"\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	// apply world space transformation\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	position.xyz	=	mul(float4(position.xyz, 1),	g_buffer.modelToWorld).xyz; \n"
"	tangent.xyz		=	mul(float4(tangent.xyz, 0),		g_buffer.modelToWorld).xyz; \n"
"	normal.xyz		=	mul(float4(normal.xyz, 0),		g_buffer.modelToWorld).xyz; \n"
"\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	// write to streamout results\n"
"	/////////////////////////////////////////////////////////////////////////////////\n"
"	output.position.xyz = position.xyz;\n"
"	output.tangent = tangent;\n"
"	output.normal = normal;\n"
"      \n"
"    inStream.Append(output);  \n"
"\n"
"}\n"
"\n"
;