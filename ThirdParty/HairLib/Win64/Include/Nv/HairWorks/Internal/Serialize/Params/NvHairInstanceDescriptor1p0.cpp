// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2013 NVIDIA Corporation. All rights reserved.

// This file was generated by NvParameterized/scripts/GenParameterized.pl
// Created: 2017.02.26 07:50:25

#include "NvHairInstanceDescriptor1p0.h"
#include <string.h>
#include <stdlib.h>

using namespace NvParameterized;

namespace nvidia
{
namespace parameterized
{
namespace legacy
{
namespace ver1p0
{

using namespace HairInstanceDescriptorNS;

const char* const HairInstanceDescriptorFactory::vptr =
    NvParameterized::getVptr<HairInstanceDescriptor, HairInstanceDescriptor::ClassAlignment>();

const uint32_t NumParamDefs = 62;
static NvParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
	45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
};

#define TENUM(type) nvidia::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NvParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 61 },
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->width), NULL, 0 }, // width
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->widthNoise), NULL, 0 }, // widthNoise
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->widthRootScale), NULL, 0 }, // widthRootScale
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->widthTipScale), NULL, 0 }, // widthTipScale
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->clumpNoise), NULL, 0 }, // clumpNoise
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->clumpRoundness), NULL, 0 }, // clumpRoundness
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->clumpScale), NULL, 0 }, // clumpScale
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->density), NULL, 0 }, // density
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->usePixelDensity), NULL, 0 }, // usePixelDensity
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->lengthNoise), NULL, 0 }, // lengthNoise
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->lengthScale), NULL, 0 }, // lengthScale
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->waveScale), NULL, 0 }, // waveScale
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->waveScaleNoise), NULL, 0 }, // waveScaleNoise
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->waveFreq), NULL, 0 }, // waveFreq
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->waveFreqNoise), NULL, 0 }, // waveFreqNoise
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->waveRootStraighten), NULL, 0 }, // waveRootStraighten
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->enableLOD), NULL, 0 }, // enableLOD
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->enableDistanceLOD), NULL, 0 }, // enableDistanceLOD
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->distanceLODStart), NULL, 0 }, // distanceLODStart
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->distanceLODEnd), NULL, 0 }, // distanceLODEnd
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->distanceLODDensity), NULL, 0 }, // distanceLODDensity
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->distanceLODWidth), NULL, 0 }, // distanceLODWidth
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->enableDetailLOD), NULL, 0 }, // enableDetailLOD
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->detailLODStart), NULL, 0 }, // detailLODStart
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->detailLODEnd), NULL, 0 }, // detailLODEnd
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->detailLODDensity), NULL, 0 }, // detailLODDensity
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->detailLODWidth), NULL, 0 }, // detailLODWidth
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useViewfrustrumCulling), NULL, 0 }, // useViewfrustrumCulling
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useBackfaceCulling), NULL, 0 }, // useBackfaceCulling
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->backfaceCullingThreshold), NULL, 0 }, // backfaceCullingThreshold
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->shadowDensityScale), NULL, 0 }, // shadowDensityScale
	{ TYPE_VEC4, false, (size_t)(&((ParametersStruct*)0)->ambientColor), NULL, 0 }, // ambientColor
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->diffuseBlend), NULL, 0 }, // diffuseBlend
	{ TYPE_VEC4, false, (size_t)(&((ParametersStruct*)0)->specularColor), NULL, 0 }, // specularColor
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->specularPrimary), NULL, 0 }, // specularPrimary
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->specularSecondary), NULL, 0 }, // specularSecondary
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->specularSecondaryOffset), NULL, 0 }, // specularSecondaryOffset
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->specularPowerPrimary), NULL, 0 }, // specularPowerPrimary
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->specularPowerSecondary), NULL, 0 }, // specularPowerSecondary
	{ TYPE_VEC4, false, (size_t)(&((ParametersStruct*)0)->rootColor), NULL, 0 }, // rootColor
	{ TYPE_VEC4, false, (size_t)(&((ParametersStruct*)0)->tipColor), NULL, 0 }, // tipColor
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->rootTipColorWeight), NULL, 0 }, // rootTipColorWeight
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->shadowSigma), NULL, 0 }, // shadowSigma
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useTextures), NULL, 0 }, // useTextures
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->castShadows), NULL, 0 }, // castShadows
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->receiveShadows), NULL, 0 }, // receiveShadows
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->backStopRadius), NULL, 0 }, // backStopRadius
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->damping), NULL, 0 }, // damping
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->massScale), NULL, 0 }, // massScale
	{ TYPE_VEC3, false, (size_t)(&((ParametersStruct*)0)->gravityDir), NULL, 0 }, // gravityDir
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->rootStiffness), NULL, 0 }, // rootStiffness
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->simulate), NULL, 0 }, // simulate
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->stiffness), NULL, 0 }, // stiffness
	{ TYPE_VEC3, false, (size_t)(&((ParametersStruct*)0)->wind), NULL, 0 }, // wind
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->windNoise), NULL, 0 }, // windNoise
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->visualizeBones), NULL, 0 }, // visualizeBones
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->visualizeGrowthMesh), NULL, 0 }, // visualizeGrowthMesh
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->visualizeGuideHairs), NULL, 0 }, // visualizeGuideHairs
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->visualizeControlVertices), NULL, 0 }, // visualizeControlVertices
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->drawRenderHairs), NULL, 0 }, // drawRenderHairs
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->colorizeMode), NULL, 0 }, // colorizeMode
};


bool HairInstanceDescriptor::mBuiltFlag = false;
NvParameterized::MutexType HairInstanceDescriptor::mBuiltFlagMutex;

HairInstanceDescriptor::HairInstanceDescriptor(NvParameterized::Traits* traits, void* buf, int32_t* refCount) :
	NvParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &HairInstanceDescriptorFactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

HairInstanceDescriptor::~HairInstanceDescriptor()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void HairInstanceDescriptor::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NvParameterized::Traits* traits = mParameterizedTraits;
	int32_t* refCount = mRefCount;
	void* buf = mBuffer;

	this->~HairInstanceDescriptor();

	NvParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NvParameterized::DefinitionImpl* HairInstanceDescriptor::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NvParameterized::DefinitionImpl* HairInstanceDescriptor::getParameterDefinitionTree(void) const
{
	HairInstanceDescriptor* tmpParam = const_cast<HairInstanceDescriptor*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NvParameterized::ErrorType HairInstanceDescriptor::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NvParameterized::ErrorType HairInstanceDescriptor::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void HairInstanceDescriptor::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<HairInstanceDescriptor::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */

void HairInstanceDescriptor::freeParameterDefinitionTable(NvParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void HairInstanceDescriptor::buildTree(void)
{

	uint32_t allocSize = sizeof(NvParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NvParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		NV_PARAM_PLACEMENT_NEW(ParamDefTable + i, NvParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="width"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("width", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "hair width in millimeters", true);
		HintTable[1].init("max", double(1000.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "width", true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="widthNoise"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("widthNoise", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "noise to hair width ", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "width noise", true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="widthRootScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("widthRootScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "scale factor for top side of the strand", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "width scale root", true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="widthTipScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("widthTipScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "scale factor for bottom side of the strand", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "width scale tip", true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="clumpNoise"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("clumpNoise", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[5].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "probability of each hair gets clumped. (0 = all hairs get clumped, 1 = clump scale is randomly distributed from 0 to 1)", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "clump noise", true);
		ParamDefTable[5].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="clumpRoundness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("clumpRoundness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(2.000000000), true);
		HintTable[1].init("min", double(0.200000003), true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "exponential factor to control roundness of clump shape. (0 = linear cone, clump scale *= power(t, roundness), where t is normalized distance from the root)", true);
		HintTable[1].init("max", double(2.000000000), true);
		HintTable[2].init("min", double(0.200000003), true);
		HintTable[3].init("shortDescription", "clump roundness", true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="clumpScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("clumpScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "how clumped each hair face is", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "clump scale", true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="density"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("density", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "ratio of number of interpolated hairs compared to maximum ", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "hair density ratio", true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="usePixelDensity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("usePixelDensity", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "use per pixel density for density map sampling", true);
		HintTable[1].init("shortDescription", "use per pixel density ", true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="lengthNoise"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("lengthNoise", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "length variation noise", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "length noise", true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="lengthScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("lengthScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[11].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "length control for growing hair effect", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "length scale", true);
		ParamDefTable[11].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="waveScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("waveScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[12].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "size of waves for hair waviness in centimeters", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "wave scale", true);
		ParamDefTable[12].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="waveScaleNoise"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("waveScaleNoise", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[13].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "noise factor for the wave scale", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "wave scale noise", true);
		ParamDefTable[13].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="waveFreq"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("waveFreq", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(10.000000000), true);
		HintTable[1].init("min", double(1.000000000), true);
		ParamDefTable[14].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "wave frequency (1.0 = one sine wave along hair length)", true);
		HintTable[1].init("max", double(10.000000000), true);
		HintTable[2].init("min", double(1.000000000), true);
		HintTable[3].init("shortDescription", "wave freq", true);
		ParamDefTable[14].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="waveFreqNoise"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("waveFreqNoise", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[15].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "noise factor for the wave frequency", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "wave freq noise", true);
		ParamDefTable[15].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="waveRootStraighten"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("waveRootStraighten", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[16].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "cutoff from root to make root not move by waviness ", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "wave root straighten", true);
		ParamDefTable[16].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="enableLOD"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("enableLOD", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "whether to enable lod", true);
		HintTable[1].init("shortDescription", "Enable LOD", true);
		ParamDefTable[17].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="enableDistanceLOD"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("enableDistanceLOD", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "whether to enable lod for far away object (distance LOD)", true);
		HintTable[1].init("shortDescription", "Enable Distance LOD", true);
		ParamDefTable[18].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="distanceLODStart"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("distanceLODStart", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "distance (in meters) to camera where fur will start fading out (by reducing density)", true);
		HintTable[1].init("max", double(1000.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "distance LOD start", true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="distanceLODEnd"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("distanceLODEnd", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "distance (in meters) to camera where fur will completely disappear (and stop simulating)", true);
		HintTable[1].init("max", double(1000.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "LOD fade end", true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="distanceLODDensity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("distanceLODDensity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "distance (in meters) to camera where fur will start fading out (by reducing density)", true);
		HintTable[1].init("max", double(1000.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "distance LOD density", true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="distanceLODWidth"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("distanceLODWidth", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "target hair width when distance LOD is triggered.", true);
		HintTable[1].init("max", double(1000.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "LOD fade end", true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="enableDetailLOD"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("enableDetailLOD", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "whether to enable lod for close object (detail LOD)", true);
		HintTable[1].init("shortDescription", "Enable Detail LOD", true);
		ParamDefTable[23].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="detailLODStart"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("detailLODStart", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "[UNIT DEPENDENT] distance (in scene unit) to camera where fur will start getting denser toward closeup density", true);
		HintTable[1].init("max", double(1000.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "closeup start", true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="detailLODEnd"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("detailLODEnd", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[25].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "[UNIT DEPENDENT] distance (in scene unit) to camera where fur will get full closeup density value", true);
		HintTable[1].init("max", double(1000.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "closeup end", true);
		ParamDefTable[25].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="detailLODDensity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("detailLODDensity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[26].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "target hair density when detail LOD is in action", true);
		HintTable[1].init("max", double(1000.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "detail LOD density", true);
		ParamDefTable[26].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="detailLODWidth"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("detailLODWidth", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[27].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "target hair width when detail up density is triggered", true);
		HintTable[1].init("max", double(1000.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "LOD fade end", true);
		ParamDefTable[27].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="useViewfrustrumCulling"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("useViewfrustrumCulling", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "when this is on, density for hairs outside view are set to 0. Use this option when fur is in a closeup.", true);
		HintTable[1].init("shortDescription", "use view frustum culling", true);
		ParamDefTable[28].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="useBackfaceCulling"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("useBackfaceCulling", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "when this is on, density for hairs growning from backfacing faces will be set to 0.", true);
		HintTable[1].init("shortDescription", "use backface culling", true);
		ParamDefTable[29].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="backfaceCullingThreshold"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("backfaceCullingThreshold", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(-1.000000000), true);
		ParamDefTable[30].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "threshold to determine backface, note that this value should be slightly smaller 0 to avoid hairs at the silhouette from disappearing", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(-1.000000000), true);
		HintTable[3].init("shortDescription", "backface culling threshold", true);
		ParamDefTable[30].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="shadowDensityScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("shadowDensityScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[31].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "density scale factor to reduce hair density for shadow map rendering", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "shadow density scale", true);
		ParamDefTable[31].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="ambientColor"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("ambientColor", TYPE_VEC4, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "ambient color", true);
		HintTable[1].init("shortDescription", "ambient color", true);
		ParamDefTable[32].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="diffuseBlend"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("diffuseBlend", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[33].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "blend factor between tangent based hair lighting vs normal based skin lighting (0 = all tangent, 1 = all normal)", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "diffuse blend", true);
		ParamDefTable[33].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="specularColor"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("specularColor", TYPE_VEC4, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.0), true);
		HintTable[1].init("min", double(0.0), true);
		ParamDefTable[34].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "specular lighing color (when specular textures are not used)", true);
		HintTable[1].init("max", double(1.0), true);
		HintTable[2].init("min", double(0.0), true);
		HintTable[3].init("shortDescription", "specular color", true);
		ParamDefTable[34].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="specularPrimary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("specularPrimary", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[35].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "primary specular factor", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "specular primary", true);
		ParamDefTable[35].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=36, longName="specularSecondary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[36];
		ParamDef->init("specularSecondary", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[36].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "secondary specular factor", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "specular secondary", true);
		ParamDefTable[36].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=37, longName="specularSecondaryOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[37];
		ParamDef->init("specularSecondaryOffset", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(-1.000000000), true);
		ParamDefTable[37].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "secondary highlight shift offset along tangents", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(-1.000000000), true);
		HintTable[3].init("shortDescription", "spec secondary offset", true);
		ParamDefTable[37].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=38, longName="specularPowerPrimary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[38];
		ParamDef->init("specularPowerPrimary", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(100.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[38].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "primary specular power exponent", true);
		HintTable[1].init("max", double(100.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "spec primary power", true);
		ParamDefTable[38].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=39, longName="specularPowerSecondary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[39];
		ParamDef->init("specularPowerSecondary", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(100.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[39].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "secondary specular power exponent", true);
		HintTable[1].init("max", double(100.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "spec secondary power", true);
		ParamDefTable[39].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=40, longName="rootColor"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[40];
		ParamDef->init("rootColor", TYPE_VEC4, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.0), true);
		HintTable[1].init("min", double(0.0), true);
		ParamDefTable[40].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "hair color for root (when root color textures are not used)", true);
		HintTable[1].init("max", double(1.0), true);
		HintTable[2].init("min", double(0.0), true);
		HintTable[3].init("shortDescription", "root color", true);
		ParamDefTable[40].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=41, longName="tipColor"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[41];
		ParamDef->init("tipColor", TYPE_VEC4, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.0), true);
		HintTable[1].init("min", double(0.0), true);
		ParamDefTable[41].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "hair color for tip (when tip color textures are not used)", true);
		HintTable[1].init("max", double(1.0), true);
		HintTable[2].init("min", double(0.0), true);
		HintTable[3].init("shortDescription", "tip color", true);
		ParamDefTable[41].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=42, longName="rootTipColorWeight"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[42];
		ParamDef->init("rootTipColorWeight", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "bias factor for root/tip color blending ", true);
		HintTable[1].init("shortDescription", "root tip color weight", true);
		ParamDefTable[42].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=43, longName="shadowSigma"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[43];
		ParamDef->init("shadowSigma", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(100.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[43].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "distance through hair volume beyond which hairs get completely shadowed.", true);
		HintTable[1].init("max", double(100.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "shadow attenuation", true);
		ParamDefTable[43].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=44, longName="useTextures"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[44];
		ParamDef->init("useTextures", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "use textures ", true);
		HintTable[1].init("shortDescription", "use textures", true);
		ParamDefTable[44].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=45, longName="castShadows"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[45];
		ParamDef->init("castShadows", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "this hair casts shadows on the scene", true);
		HintTable[1].init("shortDescription", "cast shadows", true);
		ParamDefTable[45].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=46, longName="receiveShadows"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[46];
		ParamDef->init("receiveShadows", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "this hair receives shadows from the scene", true);
		HintTable[1].init("shortDescription", "receive shadows", true);
		ParamDefTable[46].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=47, longName="backStopRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[47];
		ParamDef->init("backStopRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[47].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "[UNIT DEPENDENT] radius of backstop collision", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "backstop radius", true);
		ParamDefTable[47].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=48, longName="damping"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[48];
		ParamDef->init("damping", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(0.100000001), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[48].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "damping to slow down hair motion", true);
		HintTable[1].init("max", double(0.100000001), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "damping", true);
		ParamDefTable[48].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=49, longName="massScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[49];
		ParamDef->init("massScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.0000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[49].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "mass to scale gravity strength", true);
		HintTable[1].init("max", double(1000.0000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "massScale", true);
		ParamDefTable[49].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=50, longName="gravityDir"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[50];
		ParamDef->init("gravityDir", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.0), true);
		HintTable[1].init("min", double(-1000.0), true);
		ParamDefTable[50].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "gravity force vector direction", true);
		HintTable[1].init("max", double(1000.0), true);
		HintTable[2].init("min", double(-1000.0), true);
		HintTable[3].init("shortDescription", "gravityDir", true);
		ParamDefTable[50].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=51, longName="rootStiffness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[51];
		ParamDef->init("rootStiffness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[51].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "attenuation of stiffness away from the root (stiffer at root, weaker toward tip)", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "root stiffness", true);
		ParamDefTable[51].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=52, longName="simulate"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[52];
		ParamDef->init("simulate", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "whether to turn on/off simulation", true);
		HintTable[1].init("shortDescription", "simulate", true);
		ParamDefTable[52].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=53, longName="stiffness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[53];
		ParamDef->init("stiffness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[53].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "stiffness to restore to skinned rest shape for hairs", true);
		HintTable[1].init("max", double(1.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "stiffness", true);
		ParamDefTable[53].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=54, longName="wind"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[54];
		ParamDef->init("wind", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(1000.0), true);
		HintTable[1].init("min", double(-1000.0), true);
		ParamDefTable[54].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "vector force for main wind direction", true);
		HintTable[1].init("max", double(1000.0), true);
		HintTable[2].init("min", double(-1000.0), true);
		HintTable[3].init("shortDescription", "wind", true);
		ParamDefTable[54].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=55, longName="windNoise"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[55];
		ParamDef->init("windNoise", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", double(10.000000000), true);
		HintTable[1].init("min", double(0.000000000), true);
		ParamDefTable[55].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("longDescription", "strength of wind noise", true);
		HintTable[1].init("max", double(10.000000000), true);
		HintTable[2].init("min", double(0.000000000), true);
		HintTable[3].init("shortDescription", "wind noise", true);
		ParamDefTable[55].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=56, longName="visualizeBones"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[56];
		ParamDef->init("visualizeBones", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "draw bones ", true);
		HintTable[1].init("shortDescription", "visualize bones", true);
		ParamDefTable[56].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=57, longName="visualizeGrowthMesh"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[57];
		ParamDef->init("visualizeGrowthMesh", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "draw growth mesh", true);
		HintTable[1].init("shortDescription", "visualize growth mesh", true);
		ParamDefTable[57].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=58, longName="visualizeGuideHairs"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[58];
		ParamDef->init("visualizeGuideHairs", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "draw guide hairs", true);
		HintTable[1].init("shortDescription", "visualize guide hairs", true);
		ParamDefTable[58].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=59, longName="visualizeControlVertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[59];
		ParamDef->init("visualizeControlVertices", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "visualize control points", true);
		HintTable[1].init("shortDescription", "visualize control points", true);
		ParamDefTable[59].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=60, longName="drawRenderHairs"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[60];
		ParamDef->init("drawRenderHairs", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "draw render hair", true);
		HintTable[1].init("shortDescription", "draw render hairs", true);
		ParamDefTable[60].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=61, longName="colorizeMode"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[61];
		ParamDef->init("colorizeMode", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "show LOD factor in color (works only when non-custom pixel shader is used)", true);
		HintTable[1].init("shortDescription", "colirize LOD", true);
		ParamDefTable[61].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[61];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(2);
		Children[2] = PDEF_PTR(3);
		Children[3] = PDEF_PTR(4);
		Children[4] = PDEF_PTR(5);
		Children[5] = PDEF_PTR(6);
		Children[6] = PDEF_PTR(7);
		Children[7] = PDEF_PTR(8);
		Children[8] = PDEF_PTR(9);
		Children[9] = PDEF_PTR(10);
		Children[10] = PDEF_PTR(11);
		Children[11] = PDEF_PTR(12);
		Children[12] = PDEF_PTR(13);
		Children[13] = PDEF_PTR(14);
		Children[14] = PDEF_PTR(15);
		Children[15] = PDEF_PTR(16);
		Children[16] = PDEF_PTR(17);
		Children[17] = PDEF_PTR(18);
		Children[18] = PDEF_PTR(19);
		Children[19] = PDEF_PTR(20);
		Children[20] = PDEF_PTR(21);
		Children[21] = PDEF_PTR(22);
		Children[22] = PDEF_PTR(23);
		Children[23] = PDEF_PTR(24);
		Children[24] = PDEF_PTR(25);
		Children[25] = PDEF_PTR(26);
		Children[26] = PDEF_PTR(27);
		Children[27] = PDEF_PTR(28);
		Children[28] = PDEF_PTR(29);
		Children[29] = PDEF_PTR(30);
		Children[30] = PDEF_PTR(31);
		Children[31] = PDEF_PTR(32);
		Children[32] = PDEF_PTR(33);
		Children[33] = PDEF_PTR(34);
		Children[34] = PDEF_PTR(35);
		Children[35] = PDEF_PTR(36);
		Children[36] = PDEF_PTR(37);
		Children[37] = PDEF_PTR(38);
		Children[38] = PDEF_PTR(39);
		Children[39] = PDEF_PTR(40);
		Children[40] = PDEF_PTR(41);
		Children[41] = PDEF_PTR(42);
		Children[42] = PDEF_PTR(43);
		Children[43] = PDEF_PTR(44);
		Children[44] = PDEF_PTR(45);
		Children[45] = PDEF_PTR(46);
		Children[46] = PDEF_PTR(47);
		Children[47] = PDEF_PTR(48);
		Children[48] = PDEF_PTR(49);
		Children[49] = PDEF_PTR(50);
		Children[50] = PDEF_PTR(51);
		Children[51] = PDEF_PTR(52);
		Children[52] = PDEF_PTR(53);
		Children[53] = PDEF_PTR(54);
		Children[54] = PDEF_PTR(55);
		Children[55] = PDEF_PTR(56);
		Children[56] = PDEF_PTR(57);
		Children[57] = PDEF_PTR(58);
		Children[58] = PDEF_PTR(59);
		Children[59] = PDEF_PTR(60);
		Children[60] = PDEF_PTR(61);

		ParamDefTable[0].setChildren(Children, 61);
	}

	mBuiltFlag = true;

}
void HairInstanceDescriptor::initStrings(void)
{
}

void HairInstanceDescriptor::initDynamicArrays(void)
{
}

void HairInstanceDescriptor::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	width = float(2.000000000);
	widthNoise = float(0.000000000);
	widthRootScale = float(1.000000000);
	widthTipScale = float(0.100000001);
	clumpNoise = float(0.000000000);
	clumpRoundness = float(1.000000000);
	clumpScale = float(0.000000000);
	density = float(0.500000000);
	lengthNoise = float(1.000000000);
	lengthScale = float(1.000000000);
	waveScale = float(0.000000000);
	waveScaleNoise = float(0.500000000);
	waveFreq = float(3.000000000);
	waveFreqNoise = float(0.500000000);
	waveRootStraighten = float(0.000000000);
	enableLOD = bool(true);
	enableDistanceLOD = bool(true);
	distanceLODStart = float(5.000000000);
	distanceLODEnd = float(10.000000000);
	distanceLODDensity = float(0.000000000);
	distanceLODWidth = float(2.000000000);
	enableDetailLOD = bool(true);
	detailLODStart = float(2.000000000);
	detailLODEnd = float(1);
	detailLODDensity = float(1.000000000);
	detailLODWidth = float(1.000000000);
	backfaceCullingThreshold = float(-0.2);
	shadowDensityScale = float(1.0);
	ambientColor = nvidia::NvVec4(initVec4(0.0, 0.0, 0.0, 1.0));
	diffuseBlend = float(1.000000000);
	specularColor = nvidia::NvVec4(initVec4(0.8, 0.9, 1.0, 1.0));
	specularPrimary = float(0.100000001);
	specularSecondary = float(0.050000001);
	specularSecondaryOffset = float(0.100000001);
	specularPowerPrimary = float(100.000000000);
	specularPowerSecondary = float(20.000000000);
	rootColor = nvidia::NvVec4(initVec4(1.000000000,1.000000000,1.000000000,1.000000000));
	tipColor = nvidia::NvVec4(initVec4(1.000000000,1.000000000,1.000000000,1.000000000));
	rootTipColorWeight = float(0.500000000);
	shadowSigma = float(1.00000000);
	backStopRadius = float(0.000000000);
	damping = float(0.000000000);
	massScale = float(10.000000000);
	gravityDir = nvidia::NvVec3(init(0.000000000,0.000000000,-1.000000000));
	rootStiffness = float(0.500000000);
	stiffness = float(0.500000000);
	wind = nvidia::NvVec3(init(0.000000000,0.000000000,0.000000000));
	windNoise = float(0.000000000);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void HairInstanceDescriptor::initReferences(void)
{
}

void HairInstanceDescriptor::freeDynamicArrays(void)
{
}

void HairInstanceDescriptor::freeStrings(void)
{
}

void HairInstanceDescriptor::freeReferences(void)
{
}

} // namespace ver1p0
} // namespace legacy
} // namespace parameterized
} // namespace nvidia
